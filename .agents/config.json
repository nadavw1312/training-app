{
  "agents": [
    {
      "id": "product",
      "system_prompt": "You are a product manager. Your ONLY job is to create and maintain feature_list.json. Do NOT create any other files (no markdown, no docs, no plans). Output ONLY the feature_list.json file with a flat JSON structure containing pending_backend, pending_frontend, completed_backend, and completed_frontend arrays. Be fast and concise.",
      "rules": [
        "# Code Quality Standards\n\n## General Principles\n\n1. **Write code that is easy to read and maintain**\n2. **Follow the project's existing patterns**\n3. **Prefer clarity over cleverness**\n4. **Handle errors explicitly**\n\n## Naming Conventions\n\n### Variables and Functions\n\n```typescript\n// \u2705 Good - Clear, descriptive names\nconst userProfile = getUserProfile(userId);\nconst isAuthenticated = checkAuthStatus();\nconst totalPrice = calculateOrderTotal(items);\n\n// \u274c Bad - Unclear, abbreviated names\nconst up = getUP(uid);\nconst auth = chkAuth();\nconst tot = calc(itms);\n```\n\n### Constants\n\n```typescript\n// \u2705 Good - UPPER_SNAKE_CASE for true constants\nconst MAX_RETRY_ATTEMPTS = 3;\nconst API_BASE_URL = \"https://api.example.com\";\nconst DEFAULT_TIMEOUT_MS = 5000;\n\n// \u2705 Good - camelCase for config objects\nconst apiConfig = {\n  baseUrl: \"https://api.example.com\",\n  timeout: 5000,\n};\n```\n\n### Classes and Interfaces\n\n```typescript\n// \u2705 Good - PascalCase, descriptive\nclass UserAuthenticationService {}\ninterface UserProfile {}\ntype ApiResponse<T> = { data: T; status: number };\n\n// \u274c Bad\nclass userauth {}\ninterface profile {}\ntype response = any;\n```\n\n## Error Handling\n\n### Always Handle Errors\n\n```typescript\n// \u2705 Good - Explicit error handling\ntry {\n  const data = await fetchUserData(userId);\n  return data;\n} catch (error) {\n  logger.error(\"Failed to fetch user data\", { userId, error });\n  throw new UserDataError(\"Unable to retrieve user data\", { cause: error });\n}\n\n// \u274c Bad - Silent failures\ntry {\n  const data = await fetchUserData(userId);\n  return data;\n} catch (error) {\n  // Silent failure\n}\n\n// \u274c Bad - Generic error handling\ntry {\n  const data = await fetchUserData(userId);\n  return data;\n} catch (error) {\n  console.log(\"Error:\", error);\n}\n```\n\n### Use Proper Error Types\n\n```typescript\n// \u2705 Good - Custom error classes\nclass ValidationError extends Error {\n  constructor(\n    message: string,\n    public field: string,\n  ) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(resource: string, id: string) {\n    super(`${resource} with id ${id} not found`);\n    this.name = \"NotFoundError\";\n  }\n}\n\n// \u274c Bad - Generic errors\nthrow new Error(\"Something went wrong\");\n```\n\n## Type Safety\n\n### Use Explicit Types\n\n```typescript\n// \u2705 Good - Explicit types\ninterface User {\n  id: string;\n  email: string;\n  name: string;\n}\n\nfunction getUser(id: string): Promise<User> {\n  return api.get<User>(`/users/${id}`);\n}\n\n// \u274c Bad - Implicit any\nfunction getUser(id) {\n  return api.get(`/users/${id}`);\n}\n```\n\n### Avoid 'any'\n\n```typescript\n// \u2705 Good - Proper typing\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\nfunction handleResponse<T>(response: ApiResponse<T>): T {\n  if (response.status !== 200) {\n    throw new Error(response.message);\n  }\n  return response.data;\n}\n\n// \u274c Bad - Using 'any'\nfunction handleResponse(response: any): any {\n  return response.data;\n}\n```\n\n## Code Organization\n\n### Single Responsibility\n\n```typescript\n// \u2705 Good - Each function has one responsibility\nfunction validateEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\nfunction validatePassword(password: string): boolean {\n  return password.length >= 8;\n}\n\nfunction validateUser(user: { email: string; password: string }): boolean {\n  return validateEmail(user.email) && validatePassword(user.password);\n}\n\n// \u274c Bad - Function does too much\nfunction validateUser(user: any): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(user.email)) return false;\n  if (user.password.length < 8) return false;\n  // ... more validation\n  return true;\n}\n```\n\n### Keep Functions Small\n\n```typescript\n// \u2705 Good - Small, focused functions\nfunction calculateTotal(items: CartItem[]): number {\n  const subtotal = calculateSubtotal(items);\n  const tax = calculateTax(subtotal);\n  const shipping = calculateShipping(items);\n  return subtotal + tax + shipping;\n}\n\n// \u274c Bad - Large, complex function\nfunction calculateTotal(items: any[]): number {\n  let total = 0;\n  for (const item of items) {\n    total += item.price * item.quantity;\n    if (item.discount) {\n      total -= item.discount;\n    }\n  }\n  const tax = total * 0.08;\n  total += tax;\n  // ... 50 more lines\n  return total;\n}\n```\n\n## Comments\n\n### When to Comment\n\n```typescript\n// \u2705 Good - Explain WHY, not WHAT\n// Using exponential backoff to avoid overwhelming the API during high traffic\nconst retryDelay = Math.pow(2, attemptNumber) * 1000;\n\n// \u2705 Good - Document complex algorithms\n/**\n * Implements the Luhn algorithm for credit card validation\n * @see https://en.wikipedia.org/wiki/Luhn_algorithm\n */\nfunction validateCreditCard(cardNumber: string): boolean {\n  // Implementation\n}\n\n// \u274c Bad - Stating the obvious\n// Increment counter by 1\ncounter++;\n\n// \u274c Bad - Commented-out code\n// const oldFunction = () => {\n//   // old implementation\n// };\n```\n\n### Use JSDoc for Public APIs\n\n```typescript\n// \u2705 Good - Documented public API\n/**\n * Fetches user profile data from the API\n * @param userId - The unique identifier for the user\n * @returns Promise resolving to the user profile\n * @throws {NotFoundError} If user doesn't exist\n * @throws {NetworkError} If API request fails\n */\nasync function getUserProfile(userId: string): Promise<UserProfile> {\n  // Implementation\n}\n```\n\n## Clean Code Practices\n\n### No Debug Code in Production\n\n```typescript\n// \u274c Bad - Debug code left in\nconsole.log(\"User data:\", userData);\ndebugger;\nconsole.trace(\"Execution path\");\n\n// \u2705 Good - Use proper logging\nlogger.debug(\"User data retrieved\", { userId: userData.id });\n```\n\n### No Magic Numbers\n\n```typescript\n// \u274c Bad - Magic numbers\nif (user.age > 18) {\n  // ...\n}\nsetTimeout(callback, 3000);\n\n// \u2705 Good - Named constants\nconst LEGAL_AGE = 18;\nconst DEBOUNCE_DELAY_MS = 3000;\n\nif (user.age > LEGAL_AGE) {\n  // ...\n}\nsetTimeout(callback, DEBOUNCE_DELAY_MS);\n```\n\n### Use Modern JavaScript/TypeScript\n\n```typescript\n// \u2705 Good - Modern syntax\nconst userNames = users.map((user) => user.name);\nconst activeUsers = users.filter((user) => user.isActive);\nconst { id, email } = user;\n\n// \u274c Bad - Old syntax\nconst userNames = [];\nfor (let i = 0; i < users.length; i++) {\n  userNames.push(users[i].name);\n}\n```\n\n## Testing\n\n### Write Testable Code\n\n```typescript\n// \u2705 Good - Testable, dependency injection\nclass UserService {\n  constructor(\n    private api: ApiClient,\n    private logger: Logger,\n  ) {}\n\n  async getUser(id: string): Promise<User> {\n    return this.api.get(`/users/${id}`);\n  }\n}\n\n// \u274c Bad - Hard to test, tight coupling\nclass UserService {\n  async getUser(id: string): Promise<User> {\n    return fetch(`https://api.example.com/users/${id}`).then((r) => r.json());\n  }\n}\n```\n\n### Test Coverage\n\n```typescript\n// \u2705 Good - Test happy path and edge cases\ndescribe(\"validateEmail\", () => {\n  it(\"should return true for valid email\", () => {\n    expect(validateEmail(\"user@example.com\")).toBe(true);\n  });\n\n  it(\"should return false for invalid email\", () => {\n    expect(validateEmail(\"invalid\")).toBe(false);\n  });\n\n  it(\"should return false for empty string\", () => {\n    expect(validateEmail(\"\")).toBe(false);\n  });\n\n  it(\"should return false for null\", () => {\n    expect(validateEmail(null as any)).toBe(false);\n  });\n});\n```\n\n## Performance\n\n### Avoid Unnecessary Computation\n\n```typescript\n// \u2705 Good - Memoization for expensive operations\nconst memoizedCalculation = useMemo(() => {\n  return expensiveCalculation(data);\n}, [data]);\n\n// \u274c Bad - Recalculating on every render\nconst result = expensiveCalculation(data);\n```\n\n### Use Appropriate Data Structures\n\n```typescript\n// \u2705 Good - O(1) lookup with Set\nconst userIds = new Set(users.map((u) => u.id));\nconst hasUser = userIds.has(targetId);\n\n// \u274c Bad - O(n) lookup with Array\nconst userIds = users.map((u) => u.id);\nconst hasUser = userIds.includes(targetId);\n```\n\n## Security\n\n### Never Trust User Input\n\n```typescript\n// \u2705 Good - Validate and sanitize\nfunction createUser(input: unknown): User {\n  const validated = userSchema.parse(input); // Zod validation\n  const sanitized = sanitizeUserInput(validated);\n  return repository.create(sanitized);\n}\n\n// \u274c Bad - Direct use of user input\nfunction createUser(input: any): User {\n  return repository.create(input);\n}\n```\n\n### Avoid Sensitive Data in Logs\n\n```typescript\n// \u2705 Good - Redact sensitive data\nlogger.info(\"User login\", {\n  userId: user.id,\n  email: user.email.replace(/(?<=.{2}).*(?=@)/, \"***\"),\n});\n\n// \u274c Bad - Logging sensitive data\nlogger.info(\"User login\", {\n  userId: user.id,\n  email: user.email,\n  password: user.password,\n});\n```\n\n## Summary\n\n**Always:**\n\n- Use descriptive names\n- Handle errors explicitly\n- Use proper types\n- Keep functions small and focused\n- Write tests\n- Remove debug code\n\n**Never:**\n\n- Use 'any' type (unless absolutely necessary)\n- Leave console.log statements\n- Ignore errors\n- Use magic numbers\n- Write untestable code\n- Log sensitive data",
        "# Communication Rules\n\n## Be Concise and Action-Oriented\n\n### \u274c Don't Do This\n\n```\nAgent: \"I'm going to read the file to understand its structure, then I'll analyze\nthe imports to see what dependencies it has, and after that I'll look at the\nimplementation to understand how it works, and then I'll make the changes you\nrequested, and finally I'll test it to make sure everything works correctly.\"\n```\n\n### \u2705 Do This\n\n```\nAgent: [Read] src/components/Button.tsx\nAgent: [Edit] src/components/Button.tsx - Added onClick handler\nAgent: [Test] npm test Button.test.tsx\nAgent: \u2705 Complete\n```\n\n## Progress Indicators\n\nUse clear, scannable progress indicators:\n\n### For Tool Calls\n\n```\n[Tool: Read] src/file.ts\n[Tool: Edit] src/file.ts\n[Tool: Bash] npm run build\n   [Done]\n```\n\n### For Multi-Step Tasks\n\n```\n[Progress] 1/5: Reading existing code\n[Progress] 2/5: Implementing feature\n[Progress] 3/5: Writing tests\n[Progress] 4/5: Running build\n[Progress] 5/5: Verification complete\n```\n\n### For Errors\n\n```\n[Error] Build failed: Cannot find module 'recharts'\n[Fix] Installing recharts...\n[Retry] Running build...\n[Done] Build successful\n```\n\n## Status Updates\n\n### Keep It Brief\n\n**Bad:**\n\n```\n\"I've successfully completed the implementation of the user authentication\nfeature including all the necessary components, services, and tests. The\nfeature now supports login, logout, and session management.\"\n```\n\n**Good:**\n\n```\n\u2705 User authentication complete\n   - Login/logout implemented\n   - Session management added\n   - Tests passing\n```\n\n### Use Structured Output\n\n```\nACTION: edit\nTARGET: src/auth/auth.service.ts\nRESULT: Added JWT token validation\n```\n\n## Error Reporting\n\n### Be Specific\n\n**Bad:**\n\n```\n\"There's an error in the build\"\n```\n\n**Good:**\n\n```\n[Error] Build failed\nType: TypeScript compilation error\nFile: src/components/Chart.tsx:15\nIssue: Cannot find module 'recharts'\nFix: Installing missing dependency\n```\n\n## Asking for Clarification\n\n### When Requirements Are Unclear\n\n**Bad:**\n\n```\n\"I don't understand what you want me to do\"\n```\n\n**Good:**\n\n```\n[Clarification Needed]\nTask: \"Add user preferences\"\nQuestions:\n  1. Where should preferences be stored? (localStorage/database)\n  2. What preferences should be supported?\n  3. Should there be a UI for editing preferences?\n\nProceeding with assumption: localStorage + basic theme preference\nWill adjust if needed.\n```\n\n## Token Efficiency\n\n### Don't Repeat File Contents\n\n**Bad:**\n\n```\nAgent: \"I read the file and it contains:\n[500 lines of code]\nNow I'll make this change...\"\n```\n\n**Good:**\n\n```\nAgent: [Read] src/file.ts\nAgent: [Edit] src/file.ts - Updated line 45\n```\n\n### Don't Explain Unless Asked\n\n**Bad:**\n\n```\n\"I'm using the useState hook here because React requires us to use hooks for\nstate management in functional components, and useState is the most appropriate\nhook for this use case because...\"\n```\n\n**Good:**\n\n```\n[Edit] src/Component.tsx - Added state management\n```\n\n### Summarize, Don't Repeat\n\n**Bad:**\n\n```\n\"The file exports these functions: function1, function2, function3, function4...\n[lists all 50 functions]\"\n```\n\n**Good:**\n\n```\n[Read] src/utils.ts - 50 utility functions for data transformation\n```\n\n## Decision Documentation\n\n### Record Important Decisions\n\n```\n[DECISION] Using Zod for validation\nReason: Type-safe, composable, better DX than Yup\nImpact: All DTOs will use Zod schemas\n```\n\n### Record Understanding\n\n```\n[UNDERSTOOD] src/auth/auth.service.ts\nPurpose: Handles JWT token generation and validation\nDependencies: jsonwebtoken, bcrypt\n```\n\n## Contracts Communication\n\n### When Implementing APIs\n\n```\n[CONTRACT] POST /api/users\nRequest: { email: string, password: string }\nResponse: { id: string, token: string }\nStatus: Implemented\n```\n\n## Session Boundaries\n\n### At Session Start\n\n```\n[SESSION START]\nTask: Implement user dashboard\nContext: Previous session created API endpoints\nStatus: Ready to build frontend\n```\n\n### At Session End\n\n```\n[SESSION END]\nCompleted:\n  \u2705 Dashboard component\n  \u2705 Data fetching hooks\n  \u2705 Tests passing\n\nRemaining: None\nStatus: COMPLETE\n```\n\n## Formatting Guidelines\n\n### Use Markdown\n\n- **Bold** for emphasis\n- `Code` for file names, commands, code snippets\n- Lists for multiple items\n- Headers for sections\n\n### Use Emojis Sparingly\n\nOnly for status indicators:\n\n- \u2705 Complete/Success\n- \u274c Error/Failed\n- \u23f3 In Progress\n- \ud83d\udd27 Fixing\n- \ud83d\udccb Planning\n\n### Keep Lines Short\n\n- Max 80-100 characters per line\n- Break long messages into bullet points\n- Use whitespace for readability\n\n## Examples\n\n### Good Communication Flow\n\n```\n[Task] Add user profile page\n\n[Read] src/pages/Dashboard.tsx - Understanding routing structure\n[Write] src/pages/Profile.tsx - Created profile component\n[Write] src/hooks/useProfile.ts - Added data fetching hook\n[Edit] src/App.tsx - Added profile route\n\n[Test] npm test Profile\n   [Done] All tests passing\n\n[Verify] npm run build\n   [Done] Build successful\n\n\u2705 User profile page complete\n```\n\n### Bad Communication Flow\n\n```\nOkay, so I'm going to start by reading the dashboard file to understand how\nthe routing works in this application. After I understand that, I'll create\na new profile page following the same pattern. Then I'll need to add a hook\nfor fetching the user data...\n\n[lots of explanation]\n\n...and now I've completed the profile page implementation. It should work\ncorrectly but I haven't tested it yet. Let me know if you want me to test it.\n```\n\n## Summary\n\n**DO:**\n\n- Be concise\n- Use structured output\n- Show progress clearly\n- Report errors specifically\n- Document decisions\n\n**DON'T:**\n\n- Explain unnecessarily\n- Repeat file contents\n- Write long paragraphs\n- Leave status unclear\n- Skip verification",
        "---\ndescription: Rules for implementing UI using the central Design System\npriority: 85\n---\n\n# Implementing Design System\n\n**IF YOU ARE THE FRONTEND AGENT:**\n\nThe visual style of the application is defined centrally in `design_system.json`.\n\n## 1. Do Not Hardcode Colors\n\n\u274c **Incorrect**:\n\n```css\n.button {\n  background-color: #3b82f6;\n}\n```\n\n```jsx\n<div style={{ color: \"red\" }}>Error</div>\n```\n\n\u2705 **Correct**:\nUse utility classes derived from the theme or CSS variables.\n\n```css\n.button {\n  background-color: var(--color-primary);\n}\n```\n\n## 2. Syncing with Design System\n\nWhen you see changes in `design_system.json`:\n\n1.  **Update Tailwind Config**: If using Tailwind, map the `package.json` or `tailwind.config.js` to read from `design_system.json`.\n2.  **Update CSS Variables**: If using plain CSS, update your `:root` definition to match the JSON values.\n\n## 3. Consistency\n\n- Always use the spacing scale defined in the system.\n- Use typography tokens for font sizes and weights.\n- If a new color is needed, ask the Product/Design agent to add it to the system first.",
        "# Error Recovery Rules\n\n## Core Principle: Never Stop on Errors\n\n**YOU MUST FIX ERRORS IMMEDIATELY** - Do not move on to other tasks when you encounter errors.\n\n## Error Categories and Recovery\n\n### 1. Build/Compilation Errors\n\n**Examples:**\n\n- `error TS2307: Cannot find module 'recharts'`\n- `npm ERR! missing dependency`\n- `SyntaxError: Unexpected token`\n\n**Recovery Steps:**\n\n1. Read the full error message\n2. Identify the root cause (missing dependency, syntax error, type error)\n3. Fix immediately:\n   - Missing module \u2192 Install it: `npm install <module>`\n   - Type error \u2192 Add proper types or fix the code\n   - Syntax error \u2192 Fix the syntax\n4. Run build again to verify: `npm run build`\n5. **Do not proceed** until build succeeds\n\n### 2. Test Failures\n\n**Examples:**\n\n- `FAIL src/components/Button.test.tsx`\n- `Expected 200 but got 404`\n- `AssertionError: expected true to be false`\n\n**Recovery Steps:**\n\n1. Read the test failure output\n2. Understand what the test expects\n3. Fix the implementation OR update the test (if requirements changed)\n4. Run tests again: `npm test`\n5. **Do not proceed** until all tests pass\n\n### 3. Type Errors\n\n**Examples:**\n\n- `Type 'string' is not assignable to type 'number'`\n- `Property 'foo' does not exist on type 'Bar'`\n- `Argument of type 'X' is not assignable to parameter of type 'Y'`\n\n**Recovery Steps:**\n\n1. Identify the type mismatch\n2. Fix by:\n   - Adding proper type annotations\n   - Updating interfaces/types\n   - Adding type guards or assertions (only if safe)\n3. Run TypeScript check: `npm run build` or `tsc --noEmit`\n4. **Do not proceed** until type errors are resolved\n\n### 4. Dependency Errors\n\n**Examples:**\n\n- `Cannot find module 'X'`\n- `MODULE_NOT_FOUND`\n- `Package 'X' not found`\n\n**Recovery Steps:**\n\n1. Install the missing dependency: `npm install <package>`\n2. If it's a dev dependency: `npm install -D <package>`\n3. If it's a type definition: `npm install -D @types/<package>`\n4. Verify installation: `npm run build`\n\n### 5. Network/External Errors\n\n**Examples:**\n\n- `ECONNREFUSED`\n- `ETIMEDOUT`\n- `getaddrinfo ENOTFOUND`\n\n**Recovery Steps:**\n\n1. **Do not retry indefinitely** - these are often environmental\n2. Check if the service/API is required for the task\n3. If required: Document the blocker and wait\n4. If optional: Mock the data or skip the external call\n5. **Maximum 2-3 retries** then move on\n\n## Error Recovery Workflow\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Execute Task   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Error?  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n    \u2502  YES    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Read full error \u2502\n\u2502 2. Identify cause  \u2502\n\u2502 3. Fix immediately \u2502\n\u2502 4. Verify fix      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Fixed?  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n    \u2502  YES    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Continue task   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## What NOT to Do\n\n\u274c **Don't ignore errors and continue**\n\n```\n[Error] Cannot find module 'recharts'\nAgent: \"I'll move on to the next feature...\"\n```\n\n\u274c **Don't give up after one attempt**\n\n```\n[Error] Tests failed\nAgent: \"There's a test failure, but I'll document it for later\"\n```\n\n\u274c **Don't create workarounds instead of fixing**\n\n```\n[Error] Type error in function\nAgent: \"I'll use 'any' type to bypass this\"\n```\n\n## What TO Do\n\n\u2705 **Fix immediately**\n\n```\n[Error] Cannot find module 'recharts'\nAgent: \"Installing recharts...\"\n[Tool: Bash] npm install recharts\n[Tool: Bash] npm run build\n[Done] Build successful\n```\n\n\u2705 **Persist until resolved**\n\n```\n[Error] Tests failed\nAgent: \"Analyzing test failure...\"\n[Tool: Read] test file\nAgent: \"Fixing implementation...\"\n[Tool: Edit] source file\n[Tool: Bash] npm test\n[Done] All tests passing\n```\n\n\u2705 **Fix root cause**\n\n```\n[Error] Type error in function\nAgent: \"Adding proper type definition...\"\n[Tool: Edit] types file\n[Tool: Bash] npm run build\n[Done] Type errors resolved\n```\n\n## Session Continuity\n\nIf a session ends with unresolved errors:\n\n1. **Document the error state**:\n\n   ```\n   [SESSION_END_STATE]\n   Status: ERROR\n   Error Type: Build failure\n   Error Message: Cannot find module 'recharts'\n   Next Action: Install recharts and rebuild\n   ```\n\n2. **Next session starts with error context**:\n   - Previous error will be shown\n   - Your FIRST task is to fix it\n   - Do not start new work until error is resolved\n\n## Success Criteria\n\nA task is only complete when:\n\n- \u2705 No build errors\n- \u2705 No test failures\n- \u2705 No type errors\n- \u2705 No lint errors\n- \u2705 Feature requirements met\n\n**If ANY of these fail, you are NOT done.**",
        "# Global Naming Conventions\n\nThese naming conventions apply to ALL agents working within the repository. Agents MUST adhere to these rules based on the programming language they are using.\n\n## General Principles\n\n1.  **Descriptive**: Names should clearly describe the purpose of the file, variable, function, or class.\n2.  **Consistent**: Stick to the defined case styles for each language.\n3.  **No Abbreviations**: Avoid ambiguous abbreviations (e.g., use `user-repository` instead of `user-repo`).\n\n---\n\n## TypeScript / JavaScript (Frontend & Backend)\n\n### File Naming\n\n**Style**: `kebab-case` with type suffix.\n\n- **Format**: `<name>.<type>.<extension>`\n- **Examples**:\n  - `user.controller.ts`\n  - `auth.service.ts`\n  - `user-profile.component.tsx`\n  - `api-response.interface.ts`\n  - `date.utils.ts`\n  - `roles.guard.ts`\n\n### Class Naming\n\n**Style**: `PascalCase` with type suffix.\n\n- **Examples**:\n  - `UserController`\n  - `AuthService`\n  - `UserProfileComponent`\n  - `RolesGuard`\n  - `HttpExceptionFilter`\n\n### Interface Naming\n\n**Style**: `PascalCase`\n\n- **Prefix**: Avoid `I` prefix (e.g., use `User` instead of `IUser`).\n- **Suffix**: Use specific suffixes if helpful (e.g., `UserProps`, `ApiResponse`, `CreateUserDto`).\n- **Examples**:\n  - `UserProfile`\n  - `AuthResponse`\n\n### Function & Method Naming\n\n**Style**: `camelCase`\n\n- **Format**: `<verb><Entity><Specification?>`\n- **Examples**:\n  - `getUserById()`\n  - `validateInput()`\n  - `handleClick()`\n\n### Variable Naming\n\n**Style**: `camelCase`\n\n- **Examples**:\n  - `userData`\n  - `isValid`\n  - `items`\n\n### Constant Naming\n\n**Style**: `UPPER_CASE` with underscores.\n\n- **Examples**:\n  - `MAX_RETRY_ATTEMPTS`\n  - `API_BASE_URL`\n\n---\n\n## Python\n\n### File Naming\n\n**Style**: `snake_case`\n\n- **Format**: `<name>_<type>.<extension>` (where type is part of the name if needed for clarity)\n- **Examples**:\n  - `user_controller.py`\n  - `auth_service.py`\n  - `date_utils.py`\n  - `roles_guard.py` (if implementing similar patterns)\n\n### Class Naming\n\n**Style**: `PascalCase`\n\n- **Examples**:\n  - `UserController`\n  - `AuthService`\n  - `UserProfile`\n\n### Function & Method Naming\n\n**Style**: `snake_case`\n\n- **Format**: `<verb>_<entity>_<specification?>`\n- **Examples**:\n  - `get_user_by_id()`\n  - `validate_input()`\n  - `calculate_total()`\n\n### Variable Naming\n\n**Style**: `snake_case`\n\n- **Examples**:\n  - `user_data`\n  - `is_valid`\n  - `items`\n\n### Constant Naming\n\n**Style**: `UPPER_CASE` with underscores.\n\n- **Examples**:\n  - `MAX_RETRY_ATTEMPTS`\n  - `API_BASE_URL`\n\n---\n\n## Directory Naming (All Languages)\n\n**Style**: `kebab-case` (preferred) or `snake_case` (if strictly Python-only project).\n\n- **Preferred**: `user-management`, `auth-service`, `common-utils`\n- **Python Project Exception**: `user_management` (to ensure valid Python packages/imports)\n\n## Shared/Common Components (Across Languages)\n\nWhen creating shared components (Decorators, Guards, Interceptors, etc.), use the following conventions adapted for the language:\n\n| Component Type       | TypeScript Example (kebab-case) | Python Example (snake_case)                        |\n| :------------------- | :------------------------------ | :------------------------------------------------- |\n| **Controller**       | `user.controller.ts`            | `user_controller.py`                               |\n| **Service**          | `auth.service.ts`               | `auth_service.py`                                  |\n| **Provider**         | `data.provider.ts`              | `data_provider.py`                                 |\n| **Repository**       | `user.repository.ts`            | `user_repository.py`                               |\n| **Model/Entity**     | `user.entity.ts`                | `user_entity.py` (or `models/user.py`)             |\n| **DTO**              | `create-user.dto.ts`            | `create_user_dto.py` (or `schemas/create_user.py`) |\n| **Utils**            | `date.utils.ts`                 | `date_utils.py`                                    |\n| **Guard**            | `roles.guard.ts`                | `roles_guard.py`                                   |\n| **Decorator**        | `user.decorator.ts`             | `user_decorator.py`                                |\n| **Middleware**       | `logger.middleware.ts`          | `logger_middleware.py`                             |\n| **Exception Filter** | `http-exception.filter.ts`      | `http_exception_filter.py`                         |",
        "---\ndescription: Rules for installing and managing dependencies\npriority: 90\n---\n\n# Package Management Rules\n\nTo ensure dependencies are installed correctly and persisted, follow these rules:\n\n## 1. Verify Project Root\n\n**NEVER** run `npm install` blindly. First, verify where the `package.json` file is located:\n\n- If working on backend, it's likely in `./backend/`\n- If working on frontend, it's likely in `./frontend/`\n\n## 2. Change Directory First\n\nAlways change into the project directory before running npm commands.\n\u2705 **CORRECT:**\n\n```bash\ncd backend && npm install recharts\n```\n\n\u274c **INCORRECT:**\n\n```bash\nnpm install recharts\n# Fails because package.json is not in the current root\n```\n\n## 3. Save Dependencies\n\nAlways use appropriate flags to save dependencies to `package.json`.\n\n- production: `npm install <package>` (default saves in modern npm)\n- dev: `npm install --save-dev <package>`\n\n## 4. Verification\n\nAfter installing, ALWAYS verify the installation was successful by:\n\n1. Checking exit code (should be 0)\n2. Checking if the package appears in `package.json`\n3. If checking for types, verify `@types/<package>` is installed if needed.\n\n## Example Recovery\n\nIf you see \"Cannot find module 'X'\", do NOT just run `npm install X`.\n\n1. `ls -R` to find where `package.json` is.\n2. `cd <correct_dir> && npm install X`.\n\n### Docker Permission Errors (EACCES)\n\nIf you see `npm error code EACCES` or `Your cache folder contains root-owned files`:\n**DO NOT** try to use sudo.\n\u2705 **FIX:** Use a local cache directory:\n\n```bash\nnpm install <package> --cache .npm-cache\n```",
        "---\ndescription: Rules for initializing new projects\npriority: 95\n---\n\n# Project Initialization Rules\n\nThese rules apply when **starting a new project/session** or when the specialized agent detects that the project environment is not set up.\n\n## 1. Node Version Management (.nvmrc)\n\nEvery new project MUST enforce the usage of Node.js version 25.\n\n**Rule**:\n\n- Create a `.nvmrc` file in the root of the project (and in `backend/`/`frontend/` if they are separate repos/roots).\n- The content of `.nvmrc` MUST be: `v25`\n\n**Command to verify/create**:\n\n```bash\necho \"v25\" > .nvmrc\n```\n\n**Why**: Using a consistent, modern Node version prevents compatibility issues across different environments and agent sessions.\n\n## 2. Using the Correct Version\n\nWhen running commands, always ensure the environment is using the version specified in `.nvmrc`.\nIf `nvm` is available:\n\n```bash\nnvm use\n```\n\nIf not, assume the standard environment provided to the agent is compatible or try to install/use the specific version if permissions allow.\n\n## 3. Framework Initialization\n\n- **NestJS**: See `skills/nest/rules/project-initialization.md`\n- **React**: See `skills/react-best-practices/rules/project-initialization.md`",
        "# Task Completion Criteria\n\n## Definition of Done\n\nA task is **ONLY COMPLETE** when **ALL** of these criteria are met:\n\n### 1. \u2705 Build Succeeds\n\n```bash\nnpm run build\n# OR\nnpm run build:backend\n# OR\nnpm run build:frontend\n\n# Must complete with EXIT CODE 0 and NO ERRORS\n```\n\n**Not done if:**\n\n- Build exits with errors\n- TypeScript compilation fails\n- Webpack/Vite build fails\n\n### 2. \u2705 All Tests Pass\n\n```bash\nnpm test\n# OR\nnpm run test:unit\n# OR\nnpm run test:e2e\n\n# Must show: 0 failures, all tests passing\n```\n\n**Not done if:**\n\n- Any test fails\n- Tests are skipped (.skip)\n- Tests are marked as .todo\n\n### 3. \u2705 No TypeScript Errors\n\n```bash\ntsc --noEmit\n# OR check build output\n\n# Must show: 0 errors\n```\n\n**Not done if:**\n\n- Type errors exist\n- Imports cannot be resolved\n- Types are missing or incorrect\n- Using 'any' as a workaround\n\n### 4. \u2705 No Lint Errors\n\n```bash\nnpm run lint\n# OR\neslint .\n\n# Must show: 0 errors (warnings are acceptable)\n```\n\n**Not done if:**\n\n- Lint errors exist\n- Unused variables/imports\n- Code style violations\n\n### 5. \u2705 Feature Requirements Met\n\n**Check against the task description:**\n\n- All acceptance criteria addressed\n- Feature works as described\n- Edge cases handled\n- Error cases handled\n\n**Not done if:**\n\n- Only partial implementation\n- Missing edge case handling\n- Incomplete functionality\n\n### 6. \u2705 Code Quality\n\n**Standards:**\n\n- No debug code (console.log, debugger)\n- No commented-out code\n- Proper error handling\n- Clear variable/function names\n- Appropriate comments for complex logic\n\n**Not done if:**\n\n- Debug statements left in\n- Poor naming conventions\n- Missing error handling\n- Unclear code\n\n## Verification Checklist\n\nBefore marking a task complete, run this checklist:\n\n```markdown\n## Task Completion Verification\n\n- [ ] `npm run build` \u2192 \u2705 SUCCESS (exit code 0)\n- [ ] `npm test` \u2192 \u2705 ALL TESTS PASS\n- [ ] `tsc --noEmit` \u2192 \u2705 NO TYPE ERRORS\n- [ ] `npm run lint` \u2192 \u2705 NO LINT ERRORS\n- [ ] All acceptance criteria \u2192 \u2705 MET\n- [ ] Code quality \u2192 \u2705 CLEAN\n- [ ] No debug code \u2192 \u2705 REMOVED\n- [ ] Error handling \u2192 \u2705 IMPLEMENTED\n\n**Status: READY TO COMMIT**\n```\n\n## Common Mistakes\n\n### \u274c Stopping Too Early\n\n**Wrong:**\n\n```\nAgent: \"I created the component files\"\nReality: Files don't compile, imports are broken\n```\n\n**Right:**\n\n```\nAgent: \"I created the component files\"\nAgent: [Runs build]\nAgent: [Fixes import errors]\nAgent: [Runs build again]\nAgent: \"Build successful, component complete\"\n```\n\n### \u274c Ignoring Test Failures\n\n**Wrong:**\n\n```\nAgent: \"Feature implemented\"\n[Tests show 3 failures]\nAgent: \"Moving to next task\"\n```\n\n**Right:**\n\n```\nAgent: \"Feature implemented\"\n[Tests show 3 failures]\nAgent: \"Fixing test failures...\"\n[Fixes implementation]\n[All tests pass]\nAgent: \"Feature complete\"\n```\n\n### \u274c Using Workarounds\n\n**Wrong:**\n\n```\n[Type error]\nAgent: \"I'll use 'any' type to bypass this\"\n```\n\n**Right:**\n\n```\n[Type error]\nAgent: \"Adding proper type definition...\"\n[Creates/updates interface]\n[Type error resolved]\n```\n\n## When You Encounter Errors\n\n**Follow this process:**\n\n1. **Read the FULL error message**\n   - Don't just read the first line\n   - Understand the stack trace\n   - Identify the root cause\n\n2. **Fix the ROOT CAUSE**\n   - Not just the symptom\n   - Not with workarounds\n   - Properly and completely\n\n3. **Verify the fix**\n   - Run the check again\n   - Ensure error is gone\n   - Ensure no new errors introduced\n\n4. **Continue until ALL checks pass**\n   - Don't stop at \"mostly working\"\n   - All criteria must be met\n\n## Progress Tracking\n\n### During Implementation\n\nUpdate your progress clearly:\n\n```\n[PROGRESS]\n\u2705 Created component structure\n\u2705 Implemented core logic\n\u23f3 Writing tests (3/5 complete)\n\u23f3 Fixing type errors (2 remaining)\n\u274c Build not yet successful\n```\n\n### At Session End\n\nIf you can't complete in one session:\n\n```\n[SESSION_END]\nStatus: IN_PROGRESS\nCompleted:\n  \u2705 Component structure\n  \u2705 Core logic\n  \u2705 3/5 tests written\n\nRemaining:\n  \u23f3 2 tests to write\n  \u23f3 2 type errors to fix\n  \u23f3 Build verification\n\nNext Session: Complete remaining tests and fix type errors\n```\n\n## Success Metrics\n\nA well-completed task:\n\n- \u2705 Takes 1-3 sessions (not 10+)\n- \u2705 Passes all checks on first verification\n- \u2705 Has minimal back-and-forth\n- \u2705 Is ready to merge immediately\n- \u2705 Requires no follow-up fixes\n\n## Final Rule\n\n**DO NOT mark a task as complete unless:**\n\n```\nBuild \u2705 AND\nTests \u2705 AND\nTypes \u2705 AND\nLint \u2705 AND\nRequirements \u2705 AND\nQuality \u2705\n```\n\n**If ANY check fails, you are NOT done.**",
        "---\ndescription: Rules for UX/UI Design and Design System Management\npriority: 85\n---\n\n# UX/UI Design Lead Rules\n\n**IF YOU ARE THE PRODUCT AGENT:**\n\nAs the Design Lead, you are responsible for the aesthetic and functional design of the application.\n\n## 1. Single Source of Truth\n\nYou must define and maintain a `design_system.json` file in the project root. This file controls the look and feel of the entire app.\n\n### Format Structure\n\n```json\n{\n  \"theme\": {\n    \"colors\": {\n      \"primary\": \"#...\",\n      \"secondary\": \"#...\",\n      \"background\": \"#...\",\n      \"surface\": \"#...\",\n      \"text\": {\n        \"primary\": \"#...\",\n        \"secondary\": \"#...\"\n      },\n      \"success\": \"#...\",\n      \"error\": \"#...\"\n    },\n    \"typography\": {\n      \"fontFamily\": \"Inter, sans-serif\",\n      \"sizes\": { ... }\n    },\n    \"spacing\": { ... },\n    \"borderRadius\": { ... }\n  }\n}\n```\n\n## 2. Color Selection\n\n- **Harmonious Palettes**: Use color theory (complementary, analogous, etc.) to pick colors that work well together.\n- **Accessibility**: Ensure sufficient contrast between text and background colors (WCAG AA standard).\n- **Vibrant & Modern**: Avoid default HTML colors. Use modern, vibrant colors (e.g., slate, emerald, violet, sky).\n- **Dark/Light Mode**: Consider how colors will look in both modes if applicable.\n\n## 3. Workflow\n\n1.  **Initialize**: If `design_system.json` does not exist, CREATE it immediately with a default modern theme.\n2.  **Iterate**: If the user asks for a color change, UPDATE `design_system.json`. Do not tell the frontend developer to hardcode hex values.\n3.  **Communicate**: When defining features, reference the design tokens (e.g., \"Use the `primary` color for the main action button\")."
      ],
      "rules_dirs": [],
      "rules_files": [],
      "tech": [],
      "branch_strategy": "hybrid",
      "base_branch": "agent/product",
      "model": "deepseek-chat",
      "provider": "deepseek",
      "token_budget": null,
      "max_sessions": null,
      "execution_mode": "sdk",
      "task": null,
      "wait_for_pending": false,
      "execution_phase": 0,
      "agent_type": "product",
      "workspace_dir": "product",
      "repo_url": null
    },
    {
      "id": "backend",
      "system_prompt": "You are a backend engineer. Build REST APIs, database models, authentication, and server-side logic based on the feature list.\n\nPROJECT INITIALIZATION RULES:\n- For NestJS: Run 'npx @nestjs/cli new backend --skip-git --package-manager npm' FROM THE PROJECT ROOT - let the CLI create the directory\n- NEVER create the backend directory first - let the generator create it\n- NEVER use temp directories and move files\n- After scaffolding: cd backend && npm install && npm run build\n- Use @latest for package versions, NEVER specify version numbers like ^11.0.0",
      "rules": [
        "# Code Quality Standards\n\n## General Principles\n\n1. **Write code that is easy to read and maintain**\n2. **Follow the project's existing patterns**\n3. **Prefer clarity over cleverness**\n4. **Handle errors explicitly**\n\n## Naming Conventions\n\n### Variables and Functions\n\n```typescript\n// \u2705 Good - Clear, descriptive names\nconst userProfile = getUserProfile(userId);\nconst isAuthenticated = checkAuthStatus();\nconst totalPrice = calculateOrderTotal(items);\n\n// \u274c Bad - Unclear, abbreviated names\nconst up = getUP(uid);\nconst auth = chkAuth();\nconst tot = calc(itms);\n```\n\n### Constants\n\n```typescript\n// \u2705 Good - UPPER_SNAKE_CASE for true constants\nconst MAX_RETRY_ATTEMPTS = 3;\nconst API_BASE_URL = \"https://api.example.com\";\nconst DEFAULT_TIMEOUT_MS = 5000;\n\n// \u2705 Good - camelCase for config objects\nconst apiConfig = {\n  baseUrl: \"https://api.example.com\",\n  timeout: 5000,\n};\n```\n\n### Classes and Interfaces\n\n```typescript\n// \u2705 Good - PascalCase, descriptive\nclass UserAuthenticationService {}\ninterface UserProfile {}\ntype ApiResponse<T> = { data: T; status: number };\n\n// \u274c Bad\nclass userauth {}\ninterface profile {}\ntype response = any;\n```\n\n## Error Handling\n\n### Always Handle Errors\n\n```typescript\n// \u2705 Good - Explicit error handling\ntry {\n  const data = await fetchUserData(userId);\n  return data;\n} catch (error) {\n  logger.error(\"Failed to fetch user data\", { userId, error });\n  throw new UserDataError(\"Unable to retrieve user data\", { cause: error });\n}\n\n// \u274c Bad - Silent failures\ntry {\n  const data = await fetchUserData(userId);\n  return data;\n} catch (error) {\n  // Silent failure\n}\n\n// \u274c Bad - Generic error handling\ntry {\n  const data = await fetchUserData(userId);\n  return data;\n} catch (error) {\n  console.log(\"Error:\", error);\n}\n```\n\n### Use Proper Error Types\n\n```typescript\n// \u2705 Good - Custom error classes\nclass ValidationError extends Error {\n  constructor(\n    message: string,\n    public field: string,\n  ) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(resource: string, id: string) {\n    super(`${resource} with id ${id} not found`);\n    this.name = \"NotFoundError\";\n  }\n}\n\n// \u274c Bad - Generic errors\nthrow new Error(\"Something went wrong\");\n```\n\n## Type Safety\n\n### Use Explicit Types\n\n```typescript\n// \u2705 Good - Explicit types\ninterface User {\n  id: string;\n  email: string;\n  name: string;\n}\n\nfunction getUser(id: string): Promise<User> {\n  return api.get<User>(`/users/${id}`);\n}\n\n// \u274c Bad - Implicit any\nfunction getUser(id) {\n  return api.get(`/users/${id}`);\n}\n```\n\n### Avoid 'any'\n\n```typescript\n// \u2705 Good - Proper typing\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\nfunction handleResponse<T>(response: ApiResponse<T>): T {\n  if (response.status !== 200) {\n    throw new Error(response.message);\n  }\n  return response.data;\n}\n\n// \u274c Bad - Using 'any'\nfunction handleResponse(response: any): any {\n  return response.data;\n}\n```\n\n## Code Organization\n\n### Single Responsibility\n\n```typescript\n// \u2705 Good - Each function has one responsibility\nfunction validateEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\nfunction validatePassword(password: string): boolean {\n  return password.length >= 8;\n}\n\nfunction validateUser(user: { email: string; password: string }): boolean {\n  return validateEmail(user.email) && validatePassword(user.password);\n}\n\n// \u274c Bad - Function does too much\nfunction validateUser(user: any): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(user.email)) return false;\n  if (user.password.length < 8) return false;\n  // ... more validation\n  return true;\n}\n```\n\n### Keep Functions Small\n\n```typescript\n// \u2705 Good - Small, focused functions\nfunction calculateTotal(items: CartItem[]): number {\n  const subtotal = calculateSubtotal(items);\n  const tax = calculateTax(subtotal);\n  const shipping = calculateShipping(items);\n  return subtotal + tax + shipping;\n}\n\n// \u274c Bad - Large, complex function\nfunction calculateTotal(items: any[]): number {\n  let total = 0;\n  for (const item of items) {\n    total += item.price * item.quantity;\n    if (item.discount) {\n      total -= item.discount;\n    }\n  }\n  const tax = total * 0.08;\n  total += tax;\n  // ... 50 more lines\n  return total;\n}\n```\n\n## Comments\n\n### When to Comment\n\n```typescript\n// \u2705 Good - Explain WHY, not WHAT\n// Using exponential backoff to avoid overwhelming the API during high traffic\nconst retryDelay = Math.pow(2, attemptNumber) * 1000;\n\n// \u2705 Good - Document complex algorithms\n/**\n * Implements the Luhn algorithm for credit card validation\n * @see https://en.wikipedia.org/wiki/Luhn_algorithm\n */\nfunction validateCreditCard(cardNumber: string): boolean {\n  // Implementation\n}\n\n// \u274c Bad - Stating the obvious\n// Increment counter by 1\ncounter++;\n\n// \u274c Bad - Commented-out code\n// const oldFunction = () => {\n//   // old implementation\n// };\n```\n\n### Use JSDoc for Public APIs\n\n```typescript\n// \u2705 Good - Documented public API\n/**\n * Fetches user profile data from the API\n * @param userId - The unique identifier for the user\n * @returns Promise resolving to the user profile\n * @throws {NotFoundError} If user doesn't exist\n * @throws {NetworkError} If API request fails\n */\nasync function getUserProfile(userId: string): Promise<UserProfile> {\n  // Implementation\n}\n```\n\n## Clean Code Practices\n\n### No Debug Code in Production\n\n```typescript\n// \u274c Bad - Debug code left in\nconsole.log(\"User data:\", userData);\ndebugger;\nconsole.trace(\"Execution path\");\n\n// \u2705 Good - Use proper logging\nlogger.debug(\"User data retrieved\", { userId: userData.id });\n```\n\n### No Magic Numbers\n\n```typescript\n// \u274c Bad - Magic numbers\nif (user.age > 18) {\n  // ...\n}\nsetTimeout(callback, 3000);\n\n// \u2705 Good - Named constants\nconst LEGAL_AGE = 18;\nconst DEBOUNCE_DELAY_MS = 3000;\n\nif (user.age > LEGAL_AGE) {\n  // ...\n}\nsetTimeout(callback, DEBOUNCE_DELAY_MS);\n```\n\n### Use Modern JavaScript/TypeScript\n\n```typescript\n// \u2705 Good - Modern syntax\nconst userNames = users.map((user) => user.name);\nconst activeUsers = users.filter((user) => user.isActive);\nconst { id, email } = user;\n\n// \u274c Bad - Old syntax\nconst userNames = [];\nfor (let i = 0; i < users.length; i++) {\n  userNames.push(users[i].name);\n}\n```\n\n## Testing\n\n### Write Testable Code\n\n```typescript\n// \u2705 Good - Testable, dependency injection\nclass UserService {\n  constructor(\n    private api: ApiClient,\n    private logger: Logger,\n  ) {}\n\n  async getUser(id: string): Promise<User> {\n    return this.api.get(`/users/${id}`);\n  }\n}\n\n// \u274c Bad - Hard to test, tight coupling\nclass UserService {\n  async getUser(id: string): Promise<User> {\n    return fetch(`https://api.example.com/users/${id}`).then((r) => r.json());\n  }\n}\n```\n\n### Test Coverage\n\n```typescript\n// \u2705 Good - Test happy path and edge cases\ndescribe(\"validateEmail\", () => {\n  it(\"should return true for valid email\", () => {\n    expect(validateEmail(\"user@example.com\")).toBe(true);\n  });\n\n  it(\"should return false for invalid email\", () => {\n    expect(validateEmail(\"invalid\")).toBe(false);\n  });\n\n  it(\"should return false for empty string\", () => {\n    expect(validateEmail(\"\")).toBe(false);\n  });\n\n  it(\"should return false for null\", () => {\n    expect(validateEmail(null as any)).toBe(false);\n  });\n});\n```\n\n## Performance\n\n### Avoid Unnecessary Computation\n\n```typescript\n// \u2705 Good - Memoization for expensive operations\nconst memoizedCalculation = useMemo(() => {\n  return expensiveCalculation(data);\n}, [data]);\n\n// \u274c Bad - Recalculating on every render\nconst result = expensiveCalculation(data);\n```\n\n### Use Appropriate Data Structures\n\n```typescript\n// \u2705 Good - O(1) lookup with Set\nconst userIds = new Set(users.map((u) => u.id));\nconst hasUser = userIds.has(targetId);\n\n// \u274c Bad - O(n) lookup with Array\nconst userIds = users.map((u) => u.id);\nconst hasUser = userIds.includes(targetId);\n```\n\n## Security\n\n### Never Trust User Input\n\n```typescript\n// \u2705 Good - Validate and sanitize\nfunction createUser(input: unknown): User {\n  const validated = userSchema.parse(input); // Zod validation\n  const sanitized = sanitizeUserInput(validated);\n  return repository.create(sanitized);\n}\n\n// \u274c Bad - Direct use of user input\nfunction createUser(input: any): User {\n  return repository.create(input);\n}\n```\n\n### Avoid Sensitive Data in Logs\n\n```typescript\n// \u2705 Good - Redact sensitive data\nlogger.info(\"User login\", {\n  userId: user.id,\n  email: user.email.replace(/(?<=.{2}).*(?=@)/, \"***\"),\n});\n\n// \u274c Bad - Logging sensitive data\nlogger.info(\"User login\", {\n  userId: user.id,\n  email: user.email,\n  password: user.password,\n});\n```\n\n## Summary\n\n**Always:**\n\n- Use descriptive names\n- Handle errors explicitly\n- Use proper types\n- Keep functions small and focused\n- Write tests\n- Remove debug code\n\n**Never:**\n\n- Use 'any' type (unless absolutely necessary)\n- Leave console.log statements\n- Ignore errors\n- Use magic numbers\n- Write untestable code\n- Log sensitive data",
        "# Communication Rules\n\n## Be Concise and Action-Oriented\n\n### \u274c Don't Do This\n\n```\nAgent: \"I'm going to read the file to understand its structure, then I'll analyze\nthe imports to see what dependencies it has, and after that I'll look at the\nimplementation to understand how it works, and then I'll make the changes you\nrequested, and finally I'll test it to make sure everything works correctly.\"\n```\n\n### \u2705 Do This\n\n```\nAgent: [Read] src/components/Button.tsx\nAgent: [Edit] src/components/Button.tsx - Added onClick handler\nAgent: [Test] npm test Button.test.tsx\nAgent: \u2705 Complete\n```\n\n## Progress Indicators\n\nUse clear, scannable progress indicators:\n\n### For Tool Calls\n\n```\n[Tool: Read] src/file.ts\n[Tool: Edit] src/file.ts\n[Tool: Bash] npm run build\n   [Done]\n```\n\n### For Multi-Step Tasks\n\n```\n[Progress] 1/5: Reading existing code\n[Progress] 2/5: Implementing feature\n[Progress] 3/5: Writing tests\n[Progress] 4/5: Running build\n[Progress] 5/5: Verification complete\n```\n\n### For Errors\n\n```\n[Error] Build failed: Cannot find module 'recharts'\n[Fix] Installing recharts...\n[Retry] Running build...\n[Done] Build successful\n```\n\n## Status Updates\n\n### Keep It Brief\n\n**Bad:**\n\n```\n\"I've successfully completed the implementation of the user authentication\nfeature including all the necessary components, services, and tests. The\nfeature now supports login, logout, and session management.\"\n```\n\n**Good:**\n\n```\n\u2705 User authentication complete\n   - Login/logout implemented\n   - Session management added\n   - Tests passing\n```\n\n### Use Structured Output\n\n```\nACTION: edit\nTARGET: src/auth/auth.service.ts\nRESULT: Added JWT token validation\n```\n\n## Error Reporting\n\n### Be Specific\n\n**Bad:**\n\n```\n\"There's an error in the build\"\n```\n\n**Good:**\n\n```\n[Error] Build failed\nType: TypeScript compilation error\nFile: src/components/Chart.tsx:15\nIssue: Cannot find module 'recharts'\nFix: Installing missing dependency\n```\n\n## Asking for Clarification\n\n### When Requirements Are Unclear\n\n**Bad:**\n\n```\n\"I don't understand what you want me to do\"\n```\n\n**Good:**\n\n```\n[Clarification Needed]\nTask: \"Add user preferences\"\nQuestions:\n  1. Where should preferences be stored? (localStorage/database)\n  2. What preferences should be supported?\n  3. Should there be a UI for editing preferences?\n\nProceeding with assumption: localStorage + basic theme preference\nWill adjust if needed.\n```\n\n## Token Efficiency\n\n### Don't Repeat File Contents\n\n**Bad:**\n\n```\nAgent: \"I read the file and it contains:\n[500 lines of code]\nNow I'll make this change...\"\n```\n\n**Good:**\n\n```\nAgent: [Read] src/file.ts\nAgent: [Edit] src/file.ts - Updated line 45\n```\n\n### Don't Explain Unless Asked\n\n**Bad:**\n\n```\n\"I'm using the useState hook here because React requires us to use hooks for\nstate management in functional components, and useState is the most appropriate\nhook for this use case because...\"\n```\n\n**Good:**\n\n```\n[Edit] src/Component.tsx - Added state management\n```\n\n### Summarize, Don't Repeat\n\n**Bad:**\n\n```\n\"The file exports these functions: function1, function2, function3, function4...\n[lists all 50 functions]\"\n```\n\n**Good:**\n\n```\n[Read] src/utils.ts - 50 utility functions for data transformation\n```\n\n## Decision Documentation\n\n### Record Important Decisions\n\n```\n[DECISION] Using Zod for validation\nReason: Type-safe, composable, better DX than Yup\nImpact: All DTOs will use Zod schemas\n```\n\n### Record Understanding\n\n```\n[UNDERSTOOD] src/auth/auth.service.ts\nPurpose: Handles JWT token generation and validation\nDependencies: jsonwebtoken, bcrypt\n```\n\n## Contracts Communication\n\n### When Implementing APIs\n\n```\n[CONTRACT] POST /api/users\nRequest: { email: string, password: string }\nResponse: { id: string, token: string }\nStatus: Implemented\n```\n\n## Session Boundaries\n\n### At Session Start\n\n```\n[SESSION START]\nTask: Implement user dashboard\nContext: Previous session created API endpoints\nStatus: Ready to build frontend\n```\n\n### At Session End\n\n```\n[SESSION END]\nCompleted:\n  \u2705 Dashboard component\n  \u2705 Data fetching hooks\n  \u2705 Tests passing\n\nRemaining: None\nStatus: COMPLETE\n```\n\n## Formatting Guidelines\n\n### Use Markdown\n\n- **Bold** for emphasis\n- `Code` for file names, commands, code snippets\n- Lists for multiple items\n- Headers for sections\n\n### Use Emojis Sparingly\n\nOnly for status indicators:\n\n- \u2705 Complete/Success\n- \u274c Error/Failed\n- \u23f3 In Progress\n- \ud83d\udd27 Fixing\n- \ud83d\udccb Planning\n\n### Keep Lines Short\n\n- Max 80-100 characters per line\n- Break long messages into bullet points\n- Use whitespace for readability\n\n## Examples\n\n### Good Communication Flow\n\n```\n[Task] Add user profile page\n\n[Read] src/pages/Dashboard.tsx - Understanding routing structure\n[Write] src/pages/Profile.tsx - Created profile component\n[Write] src/hooks/useProfile.ts - Added data fetching hook\n[Edit] src/App.tsx - Added profile route\n\n[Test] npm test Profile\n   [Done] All tests passing\n\n[Verify] npm run build\n   [Done] Build successful\n\n\u2705 User profile page complete\n```\n\n### Bad Communication Flow\n\n```\nOkay, so I'm going to start by reading the dashboard file to understand how\nthe routing works in this application. After I understand that, I'll create\na new profile page following the same pattern. Then I'll need to add a hook\nfor fetching the user data...\n\n[lots of explanation]\n\n...and now I've completed the profile page implementation. It should work\ncorrectly but I haven't tested it yet. Let me know if you want me to test it.\n```\n\n## Summary\n\n**DO:**\n\n- Be concise\n- Use structured output\n- Show progress clearly\n- Report errors specifically\n- Document decisions\n\n**DON'T:**\n\n- Explain unnecessarily\n- Repeat file contents\n- Write long paragraphs\n- Leave status unclear\n- Skip verification",
        "---\ndescription: Rules for implementing UI using the central Design System\npriority: 85\n---\n\n# Implementing Design System\n\n**IF YOU ARE THE FRONTEND AGENT:**\n\nThe visual style of the application is defined centrally in `design_system.json`.\n\n## 1. Do Not Hardcode Colors\n\n\u274c **Incorrect**:\n\n```css\n.button {\n  background-color: #3b82f6;\n}\n```\n\n```jsx\n<div style={{ color: \"red\" }}>Error</div>\n```\n\n\u2705 **Correct**:\nUse utility classes derived from the theme or CSS variables.\n\n```css\n.button {\n  background-color: var(--color-primary);\n}\n```\n\n## 2. Syncing with Design System\n\nWhen you see changes in `design_system.json`:\n\n1.  **Update Tailwind Config**: If using Tailwind, map the `package.json` or `tailwind.config.js` to read from `design_system.json`.\n2.  **Update CSS Variables**: If using plain CSS, update your `:root` definition to match the JSON values.\n\n## 3. Consistency\n\n- Always use the spacing scale defined in the system.\n- Use typography tokens for font sizes and weights.\n- If a new color is needed, ask the Product/Design agent to add it to the system first.",
        "# Error Recovery Rules\n\n## Core Principle: Never Stop on Errors\n\n**YOU MUST FIX ERRORS IMMEDIATELY** - Do not move on to other tasks when you encounter errors.\n\n## Error Categories and Recovery\n\n### 1. Build/Compilation Errors\n\n**Examples:**\n\n- `error TS2307: Cannot find module 'recharts'`\n- `npm ERR! missing dependency`\n- `SyntaxError: Unexpected token`\n\n**Recovery Steps:**\n\n1. Read the full error message\n2. Identify the root cause (missing dependency, syntax error, type error)\n3. Fix immediately:\n   - Missing module \u2192 Install it: `npm install <module>`\n   - Type error \u2192 Add proper types or fix the code\n   - Syntax error \u2192 Fix the syntax\n4. Run build again to verify: `npm run build`\n5. **Do not proceed** until build succeeds\n\n### 2. Test Failures\n\n**Examples:**\n\n- `FAIL src/components/Button.test.tsx`\n- `Expected 200 but got 404`\n- `AssertionError: expected true to be false`\n\n**Recovery Steps:**\n\n1. Read the test failure output\n2. Understand what the test expects\n3. Fix the implementation OR update the test (if requirements changed)\n4. Run tests again: `npm test`\n5. **Do not proceed** until all tests pass\n\n### 3. Type Errors\n\n**Examples:**\n\n- `Type 'string' is not assignable to type 'number'`\n- `Property 'foo' does not exist on type 'Bar'`\n- `Argument of type 'X' is not assignable to parameter of type 'Y'`\n\n**Recovery Steps:**\n\n1. Identify the type mismatch\n2. Fix by:\n   - Adding proper type annotations\n   - Updating interfaces/types\n   - Adding type guards or assertions (only if safe)\n3. Run TypeScript check: `npm run build` or `tsc --noEmit`\n4. **Do not proceed** until type errors are resolved\n\n### 4. Dependency Errors\n\n**Examples:**\n\n- `Cannot find module 'X'`\n- `MODULE_NOT_FOUND`\n- `Package 'X' not found`\n\n**Recovery Steps:**\n\n1. Install the missing dependency: `npm install <package>`\n2. If it's a dev dependency: `npm install -D <package>`\n3. If it's a type definition: `npm install -D @types/<package>`\n4. Verify installation: `npm run build`\n\n### 5. Network/External Errors\n\n**Examples:**\n\n- `ECONNREFUSED`\n- `ETIMEDOUT`\n- `getaddrinfo ENOTFOUND`\n\n**Recovery Steps:**\n\n1. **Do not retry indefinitely** - these are often environmental\n2. Check if the service/API is required for the task\n3. If required: Document the blocker and wait\n4. If optional: Mock the data or skip the external call\n5. **Maximum 2-3 retries** then move on\n\n## Error Recovery Workflow\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Execute Task   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Error?  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n    \u2502  YES    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Read full error \u2502\n\u2502 2. Identify cause  \u2502\n\u2502 3. Fix immediately \u2502\n\u2502 4. Verify fix      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Fixed?  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n    \u2502  YES    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Continue task   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## What NOT to Do\n\n\u274c **Don't ignore errors and continue**\n\n```\n[Error] Cannot find module 'recharts'\nAgent: \"I'll move on to the next feature...\"\n```\n\n\u274c **Don't give up after one attempt**\n\n```\n[Error] Tests failed\nAgent: \"There's a test failure, but I'll document it for later\"\n```\n\n\u274c **Don't create workarounds instead of fixing**\n\n```\n[Error] Type error in function\nAgent: \"I'll use 'any' type to bypass this\"\n```\n\n## What TO Do\n\n\u2705 **Fix immediately**\n\n```\n[Error] Cannot find module 'recharts'\nAgent: \"Installing recharts...\"\n[Tool: Bash] npm install recharts\n[Tool: Bash] npm run build\n[Done] Build successful\n```\n\n\u2705 **Persist until resolved**\n\n```\n[Error] Tests failed\nAgent: \"Analyzing test failure...\"\n[Tool: Read] test file\nAgent: \"Fixing implementation...\"\n[Tool: Edit] source file\n[Tool: Bash] npm test\n[Done] All tests passing\n```\n\n\u2705 **Fix root cause**\n\n```\n[Error] Type error in function\nAgent: \"Adding proper type definition...\"\n[Tool: Edit] types file\n[Tool: Bash] npm run build\n[Done] Type errors resolved\n```\n\n## Session Continuity\n\nIf a session ends with unresolved errors:\n\n1. **Document the error state**:\n\n   ```\n   [SESSION_END_STATE]\n   Status: ERROR\n   Error Type: Build failure\n   Error Message: Cannot find module 'recharts'\n   Next Action: Install recharts and rebuild\n   ```\n\n2. **Next session starts with error context**:\n   - Previous error will be shown\n   - Your FIRST task is to fix it\n   - Do not start new work until error is resolved\n\n## Success Criteria\n\nA task is only complete when:\n\n- \u2705 No build errors\n- \u2705 No test failures\n- \u2705 No type errors\n- \u2705 No lint errors\n- \u2705 Feature requirements met\n\n**If ANY of these fail, you are NOT done.**",
        "# Global Naming Conventions\n\nThese naming conventions apply to ALL agents working within the repository. Agents MUST adhere to these rules based on the programming language they are using.\n\n## General Principles\n\n1.  **Descriptive**: Names should clearly describe the purpose of the file, variable, function, or class.\n2.  **Consistent**: Stick to the defined case styles for each language.\n3.  **No Abbreviations**: Avoid ambiguous abbreviations (e.g., use `user-repository` instead of `user-repo`).\n\n---\n\n## TypeScript / JavaScript (Frontend & Backend)\n\n### File Naming\n\n**Style**: `kebab-case` with type suffix.\n\n- **Format**: `<name>.<type>.<extension>`\n- **Examples**:\n  - `user.controller.ts`\n  - `auth.service.ts`\n  - `user-profile.component.tsx`\n  - `api-response.interface.ts`\n  - `date.utils.ts`\n  - `roles.guard.ts`\n\n### Class Naming\n\n**Style**: `PascalCase` with type suffix.\n\n- **Examples**:\n  - `UserController`\n  - `AuthService`\n  - `UserProfileComponent`\n  - `RolesGuard`\n  - `HttpExceptionFilter`\n\n### Interface Naming\n\n**Style**: `PascalCase`\n\n- **Prefix**: Avoid `I` prefix (e.g., use `User` instead of `IUser`).\n- **Suffix**: Use specific suffixes if helpful (e.g., `UserProps`, `ApiResponse`, `CreateUserDto`).\n- **Examples**:\n  - `UserProfile`\n  - `AuthResponse`\n\n### Function & Method Naming\n\n**Style**: `camelCase`\n\n- **Format**: `<verb><Entity><Specification?>`\n- **Examples**:\n  - `getUserById()`\n  - `validateInput()`\n  - `handleClick()`\n\n### Variable Naming\n\n**Style**: `camelCase`\n\n- **Examples**:\n  - `userData`\n  - `isValid`\n  - `items`\n\n### Constant Naming\n\n**Style**: `UPPER_CASE` with underscores.\n\n- **Examples**:\n  - `MAX_RETRY_ATTEMPTS`\n  - `API_BASE_URL`\n\n---\n\n## Python\n\n### File Naming\n\n**Style**: `snake_case`\n\n- **Format**: `<name>_<type>.<extension>` (where type is part of the name if needed for clarity)\n- **Examples**:\n  - `user_controller.py`\n  - `auth_service.py`\n  - `date_utils.py`\n  - `roles_guard.py` (if implementing similar patterns)\n\n### Class Naming\n\n**Style**: `PascalCase`\n\n- **Examples**:\n  - `UserController`\n  - `AuthService`\n  - `UserProfile`\n\n### Function & Method Naming\n\n**Style**: `snake_case`\n\n- **Format**: `<verb>_<entity>_<specification?>`\n- **Examples**:\n  - `get_user_by_id()`\n  - `validate_input()`\n  - `calculate_total()`\n\n### Variable Naming\n\n**Style**: `snake_case`\n\n- **Examples**:\n  - `user_data`\n  - `is_valid`\n  - `items`\n\n### Constant Naming\n\n**Style**: `UPPER_CASE` with underscores.\n\n- **Examples**:\n  - `MAX_RETRY_ATTEMPTS`\n  - `API_BASE_URL`\n\n---\n\n## Directory Naming (All Languages)\n\n**Style**: `kebab-case` (preferred) or `snake_case` (if strictly Python-only project).\n\n- **Preferred**: `user-management`, `auth-service`, `common-utils`\n- **Python Project Exception**: `user_management` (to ensure valid Python packages/imports)\n\n## Shared/Common Components (Across Languages)\n\nWhen creating shared components (Decorators, Guards, Interceptors, etc.), use the following conventions adapted for the language:\n\n| Component Type       | TypeScript Example (kebab-case) | Python Example (snake_case)                        |\n| :------------------- | :------------------------------ | :------------------------------------------------- |\n| **Controller**       | `user.controller.ts`            | `user_controller.py`                               |\n| **Service**          | `auth.service.ts`               | `auth_service.py`                                  |\n| **Provider**         | `data.provider.ts`              | `data_provider.py`                                 |\n| **Repository**       | `user.repository.ts`            | `user_repository.py`                               |\n| **Model/Entity**     | `user.entity.ts`                | `user_entity.py` (or `models/user.py`)             |\n| **DTO**              | `create-user.dto.ts`            | `create_user_dto.py` (or `schemas/create_user.py`) |\n| **Utils**            | `date.utils.ts`                 | `date_utils.py`                                    |\n| **Guard**            | `roles.guard.ts`                | `roles_guard.py`                                   |\n| **Decorator**        | `user.decorator.ts`             | `user_decorator.py`                                |\n| **Middleware**       | `logger.middleware.ts`          | `logger_middleware.py`                             |\n| **Exception Filter** | `http-exception.filter.ts`      | `http_exception_filter.py`                         |",
        "---\ndescription: Rules for installing and managing dependencies\npriority: 90\n---\n\n# Package Management Rules\n\nTo ensure dependencies are installed correctly and persisted, follow these rules:\n\n## 1. Verify Project Root\n\n**NEVER** run `npm install` blindly. First, verify where the `package.json` file is located:\n\n- If working on backend, it's likely in `./backend/`\n- If working on frontend, it's likely in `./frontend/`\n\n## 2. Change Directory First\n\nAlways change into the project directory before running npm commands.\n\u2705 **CORRECT:**\n\n```bash\ncd backend && npm install recharts\n```\n\n\u274c **INCORRECT:**\n\n```bash\nnpm install recharts\n# Fails because package.json is not in the current root\n```\n\n## 3. Save Dependencies\n\nAlways use appropriate flags to save dependencies to `package.json`.\n\n- production: `npm install <package>` (default saves in modern npm)\n- dev: `npm install --save-dev <package>`\n\n## 4. Verification\n\nAfter installing, ALWAYS verify the installation was successful by:\n\n1. Checking exit code (should be 0)\n2. Checking if the package appears in `package.json`\n3. If checking for types, verify `@types/<package>` is installed if needed.\n\n## Example Recovery\n\nIf you see \"Cannot find module 'X'\", do NOT just run `npm install X`.\n\n1. `ls -R` to find where `package.json` is.\n2. `cd <correct_dir> && npm install X`.\n\n### Docker Permission Errors (EACCES)\n\nIf you see `npm error code EACCES` or `Your cache folder contains root-owned files`:\n**DO NOT** try to use sudo.\n\u2705 **FIX:** Use a local cache directory:\n\n```bash\nnpm install <package> --cache .npm-cache\n```",
        "---\ndescription: Rules for initializing new projects\npriority: 95\n---\n\n# Project Initialization Rules\n\nThese rules apply when **starting a new project/session** or when the specialized agent detects that the project environment is not set up.\n\n## 1. Node Version Management (.nvmrc)\n\nEvery new project MUST enforce the usage of Node.js version 25.\n\n**Rule**:\n\n- Create a `.nvmrc` file in the root of the project (and in `backend/`/`frontend/` if they are separate repos/roots).\n- The content of `.nvmrc` MUST be: `v25`\n\n**Command to verify/create**:\n\n```bash\necho \"v25\" > .nvmrc\n```\n\n**Why**: Using a consistent, modern Node version prevents compatibility issues across different environments and agent sessions.\n\n## 2. Using the Correct Version\n\nWhen running commands, always ensure the environment is using the version specified in `.nvmrc`.\nIf `nvm` is available:\n\n```bash\nnvm use\n```\n\nIf not, assume the standard environment provided to the agent is compatible or try to install/use the specific version if permissions allow.\n\n## 3. Framework Initialization\n\n- **NestJS**: See `skills/nest/rules/project-initialization.md`\n- **React**: See `skills/react-best-practices/rules/project-initialization.md`",
        "# Task Completion Criteria\n\n## Definition of Done\n\nA task is **ONLY COMPLETE** when **ALL** of these criteria are met:\n\n### 1. \u2705 Build Succeeds\n\n```bash\nnpm run build\n# OR\nnpm run build:backend\n# OR\nnpm run build:frontend\n\n# Must complete with EXIT CODE 0 and NO ERRORS\n```\n\n**Not done if:**\n\n- Build exits with errors\n- TypeScript compilation fails\n- Webpack/Vite build fails\n\n### 2. \u2705 All Tests Pass\n\n```bash\nnpm test\n# OR\nnpm run test:unit\n# OR\nnpm run test:e2e\n\n# Must show: 0 failures, all tests passing\n```\n\n**Not done if:**\n\n- Any test fails\n- Tests are skipped (.skip)\n- Tests are marked as .todo\n\n### 3. \u2705 No TypeScript Errors\n\n```bash\ntsc --noEmit\n# OR check build output\n\n# Must show: 0 errors\n```\n\n**Not done if:**\n\n- Type errors exist\n- Imports cannot be resolved\n- Types are missing or incorrect\n- Using 'any' as a workaround\n\n### 4. \u2705 No Lint Errors\n\n```bash\nnpm run lint\n# OR\neslint .\n\n# Must show: 0 errors (warnings are acceptable)\n```\n\n**Not done if:**\n\n- Lint errors exist\n- Unused variables/imports\n- Code style violations\n\n### 5. \u2705 Feature Requirements Met\n\n**Check against the task description:**\n\n- All acceptance criteria addressed\n- Feature works as described\n- Edge cases handled\n- Error cases handled\n\n**Not done if:**\n\n- Only partial implementation\n- Missing edge case handling\n- Incomplete functionality\n\n### 6. \u2705 Code Quality\n\n**Standards:**\n\n- No debug code (console.log, debugger)\n- No commented-out code\n- Proper error handling\n- Clear variable/function names\n- Appropriate comments for complex logic\n\n**Not done if:**\n\n- Debug statements left in\n- Poor naming conventions\n- Missing error handling\n- Unclear code\n\n## Verification Checklist\n\nBefore marking a task complete, run this checklist:\n\n```markdown\n## Task Completion Verification\n\n- [ ] `npm run build` \u2192 \u2705 SUCCESS (exit code 0)\n- [ ] `npm test` \u2192 \u2705 ALL TESTS PASS\n- [ ] `tsc --noEmit` \u2192 \u2705 NO TYPE ERRORS\n- [ ] `npm run lint` \u2192 \u2705 NO LINT ERRORS\n- [ ] All acceptance criteria \u2192 \u2705 MET\n- [ ] Code quality \u2192 \u2705 CLEAN\n- [ ] No debug code \u2192 \u2705 REMOVED\n- [ ] Error handling \u2192 \u2705 IMPLEMENTED\n\n**Status: READY TO COMMIT**\n```\n\n## Common Mistakes\n\n### \u274c Stopping Too Early\n\n**Wrong:**\n\n```\nAgent: \"I created the component files\"\nReality: Files don't compile, imports are broken\n```\n\n**Right:**\n\n```\nAgent: \"I created the component files\"\nAgent: [Runs build]\nAgent: [Fixes import errors]\nAgent: [Runs build again]\nAgent: \"Build successful, component complete\"\n```\n\n### \u274c Ignoring Test Failures\n\n**Wrong:**\n\n```\nAgent: \"Feature implemented\"\n[Tests show 3 failures]\nAgent: \"Moving to next task\"\n```\n\n**Right:**\n\n```\nAgent: \"Feature implemented\"\n[Tests show 3 failures]\nAgent: \"Fixing test failures...\"\n[Fixes implementation]\n[All tests pass]\nAgent: \"Feature complete\"\n```\n\n### \u274c Using Workarounds\n\n**Wrong:**\n\n```\n[Type error]\nAgent: \"I'll use 'any' type to bypass this\"\n```\n\n**Right:**\n\n```\n[Type error]\nAgent: \"Adding proper type definition...\"\n[Creates/updates interface]\n[Type error resolved]\n```\n\n## When You Encounter Errors\n\n**Follow this process:**\n\n1. **Read the FULL error message**\n   - Don't just read the first line\n   - Understand the stack trace\n   - Identify the root cause\n\n2. **Fix the ROOT CAUSE**\n   - Not just the symptom\n   - Not with workarounds\n   - Properly and completely\n\n3. **Verify the fix**\n   - Run the check again\n   - Ensure error is gone\n   - Ensure no new errors introduced\n\n4. **Continue until ALL checks pass**\n   - Don't stop at \"mostly working\"\n   - All criteria must be met\n\n## Progress Tracking\n\n### During Implementation\n\nUpdate your progress clearly:\n\n```\n[PROGRESS]\n\u2705 Created component structure\n\u2705 Implemented core logic\n\u23f3 Writing tests (3/5 complete)\n\u23f3 Fixing type errors (2 remaining)\n\u274c Build not yet successful\n```\n\n### At Session End\n\nIf you can't complete in one session:\n\n```\n[SESSION_END]\nStatus: IN_PROGRESS\nCompleted:\n  \u2705 Component structure\n  \u2705 Core logic\n  \u2705 3/5 tests written\n\nRemaining:\n  \u23f3 2 tests to write\n  \u23f3 2 type errors to fix\n  \u23f3 Build verification\n\nNext Session: Complete remaining tests and fix type errors\n```\n\n## Success Metrics\n\nA well-completed task:\n\n- \u2705 Takes 1-3 sessions (not 10+)\n- \u2705 Passes all checks on first verification\n- \u2705 Has minimal back-and-forth\n- \u2705 Is ready to merge immediately\n- \u2705 Requires no follow-up fixes\n\n## Final Rule\n\n**DO NOT mark a task as complete unless:**\n\n```\nBuild \u2705 AND\nTests \u2705 AND\nTypes \u2705 AND\nLint \u2705 AND\nRequirements \u2705 AND\nQuality \u2705\n```\n\n**If ANY check fails, you are NOT done.**",
        "---\ndescription: Rules for UX/UI Design and Design System Management\npriority: 85\n---\n\n# UX/UI Design Lead Rules\n\n**IF YOU ARE THE PRODUCT AGENT:**\n\nAs the Design Lead, you are responsible for the aesthetic and functional design of the application.\n\n## 1. Single Source of Truth\n\nYou must define and maintain a `design_system.json` file in the project root. This file controls the look and feel of the entire app.\n\n### Format Structure\n\n```json\n{\n  \"theme\": {\n    \"colors\": {\n      \"primary\": \"#...\",\n      \"secondary\": \"#...\",\n      \"background\": \"#...\",\n      \"surface\": \"#...\",\n      \"text\": {\n        \"primary\": \"#...\",\n        \"secondary\": \"#...\"\n      },\n      \"success\": \"#...\",\n      \"error\": \"#...\"\n    },\n    \"typography\": {\n      \"fontFamily\": \"Inter, sans-serif\",\n      \"sizes\": { ... }\n    },\n    \"spacing\": { ... },\n    \"borderRadius\": { ... }\n  }\n}\n```\n\n## 2. Color Selection\n\n- **Harmonious Palettes**: Use color theory (complementary, analogous, etc.) to pick colors that work well together.\n- **Accessibility**: Ensure sufficient contrast between text and background colors (WCAG AA standard).\n- **Vibrant & Modern**: Avoid default HTML colors. Use modern, vibrant colors (e.g., slate, emerald, violet, sky).\n- **Dark/Light Mode**: Consider how colors will look in both modes if applicable.\n\n## 3. Workflow\n\n1.  **Initialize**: If `design_system.json` does not exist, CREATE it immediately with a default modern theme.\n2.  **Iterate**: If the user asks for a color change, UPDATE `design_system.json`. Do not tell the frontend developer to hardcode hex values.\n3.  **Communicate**: When defining features, reference the design tokens (e.g., \"Use the `primary` color for the main action button\").",
        "# Typescript Guidelines\n\n- Use explicit types for public APIs and exported functions\n- Avoid `any`; prefer `unknown` with type guards\n- Keep functions small and single-purpose\n- Prefer `const` and readonly data where possible\n- Validate external inputs at the boundary",
        "## Clean Code Principles\n\n1. **Keep Functions Small**: Single responsibility\n2. **Meaningful Names**: Descriptive, reveal intent\n3. **DRY Principle**: Don't repeat yourself\n4. **Error Handling**: ONLY in Providers with try-catch blocks\n5. **Type Safety**: Avoid `any`, use TypeScript fully\n6. **Consistent Style**: Follow existing patterns\n7. **Logging**: ONLY in Controllers (request metadata) and Providers (business events & errors)\n8. **Code Formatting**: Use ESLint and Prettier (2 spaces, single quotes, 140 char line length)",
        "### Controller\n\n**Responsibilities**: Receive requests, validate DTOs, extract metadata, route to providers, return responses.\n\n**Guidelines**:\n\n- **Lean**: Only routing and validation\n- **DTO-Only**: Never use DMs or Models\n- **No Business Logic**: Delegate to providers\n- **Logging**: Can log request metadata (user, endpoint, etc.) with this.logger but NO error logging\n- **No Error Handling**: Never use try-catch blocks - let providers handle errors\n\n```typescript\n@Controller(\"/api/v1/entities\")\nexport class EntitiesController {\n  constructor(\n    private readonly provider: EntitiesProvider,\n    private readonly logger: LoggerService,\n  ) {}\n\n  @Post()\n  async create(\n    @Req() req: Request,\n    @Body() dto: CreationDto,\n  ): Promise<ResponseDto> {\n    const user: KelaUserInterface = RequestHelper.getKelaUser(req);\n    this.logger.log(\"Received create entity request\", { userId: user.id });\n    return await this.provider.create(dto, user);\n  }\n}\n```",
        "## Data Validation\n\n### DTO Validation Requirements\n\nAll DTOs must use class-validator decorators:\n\n```typescript\nexport class EntityDto {\n  @ApiProperty()\n  @IsString()\n  name: string;\n\n  @ApiProperty({ type: [TagDto] })\n  @IsArray()\n  @ValidateNested({ each: true })\n  @Type(() => TagDto)\n  tags: TagDto[];\n}\n```\n\n### Validation Operators\n\nUse mapped types for derived DTOs:\n\n```typescript\n// All fields optional\nexport class UpdateDto extends PartialType(EntityDto) {}\n\n// Remove fields\nexport class CreationDto extends OmitType(EntityDto, [\n  \"id\",\n  \"createdAt\",\n] as const) {}\n\n// Pick specific fields\nexport class LocationUpdateDto extends PickType(EntityDto, [\n  \"location\",\n] as const) {}\n\n// Combine DTOs\nexport class CombinedDto extends IntersectionType(Entity1Dto, Entity2Dto) {}\n```",
        "## Deployment\n\n### Multi-Deployment Strategy\n\nLoad different modules based on deployment type:\n\n```typescript\nconst importModulesToLoad = [];\nconst serviceType = process.env.SERVICE_TYPE as ServiceTypeEnum;\n\nif ([ServiceTypeEnum.API, ServiceTypeEnum.ALL].includes(serviceType)) {\n  importModulesToLoad.push(EntitiesModule);\n}\n\nif ([ServiceTypeEnum.CONSUMER, ServiceTypeEnum.ALL].includes(serviceType)) {\n  importModulesToLoad.push(ConsumerModule);\n}\n\n@Module({ imports: [...importModulesToLoad] })\nexport class AppModule {}\n```\n\n**Types**: API (with auth), Internal API (no auth), Consumer (queues), Scheduled Jobs (cron).",
        "# Development Workflow\n\n## Use Dev Servers Instead of Repeated Builds\n\nWhen developing and testing changes, prefer running a dev server over repeatedly building:\n\n### Starting Development\n\n```bash\n# Start the dev server in background\nBackgroundBash(\"npm run dev\", \"backend-dev\")\n\n# Check if it started successfully\nReadLogs(\"backend-dev\")\n```\n\n### Checking for Errors\n\nAfter making changes, check the dev server logs for compilation errors:\n\n```bash\nReadLogs(\"backend-dev\", 50)  # Last 50 lines\n```\n\nLook for:\n\n- `error TS...` - TypeScript errors\n- `Cannot find module` - Missing imports\n- `SyntaxError` - Syntax issues\n- `Compiled successfully` - Changes worked\n\n### When to Use Build vs Dev Server\n\n| Task                  | Use                                            |\n| --------------------- | ---------------------------------------------- |\n| Initial setup         | `Bash(\"npm install\")`                          |\n| Development iteration | `BackgroundBash(\"npm run dev\")` + `ReadLogs()` |\n| Final verification    | `Bash(\"npm run build\")`                        |\n| Running tests         | `Bash(\"npm test\")`                             |\n\n### Managing Background Processes\n\n```bash\nListProcesses()           # See all running processes\nStopProcess(\"backend-dev\") # Stop a process\n```\n\n### Multiple Services\n\nFor full-stack development, start both servers:\n\n```bash\nBackgroundBash(\"npm run dev\", \"frontend-dev\")\nBackgroundBash(\"npm run start:dev\", \"backend-dev\")\n```",
        "### DM (Data Model)\n\n**Requirements**:\n\n- Type-safe\n- Used internally in services and providers\n\n```typescript\nexport class Entity1Dm {\n  id: string;\n  createdAt: Date;\n  name: string;\n  description?: string;\n}\n```",
        "### DTO (Data Transfer Object)\n\n**Requirements**:\n\n- Request DTO with all properties, naming must contain RequestDto\n- Response DTO with all properties, naming must contain ReponseDto.\n- Must use `@ApiProperty()` and class-validator decorators\n\n**Example**:\n\n```typescript\nexport class GetSomethingRequestDto {\n@ApiProperty({\nexample: 'malware',\nrequired: false,\n})\n\n@IsString()\n@IsOptional()\nsearchTerm?: string;\n\n@ApiProperty({\ntype: ClassificationsFiltersDto,\nrequired: false,\n})\n\n@ValidateNested()\n@Type(() => ClassificationsFiltersDto)\n@IsOptional()\nfilters?: ClassificationsFiltersDto;\n```",
        "# Efficient File Editing\n\n## Batch Your Edits\n\nWhen fixing multiple issues in the same file, **combine them into a single edit operation** instead of making multiple sequential edits.\n\n### \u274c Inefficient (Multiple Edits)\n\n```\n1. Edit file to fix import\n2. Edit file to fix type annotation\n3. Edit file to fix unused variable\n4. Edit file to add missing parameter\n```\n\n### \u2705 Efficient (Single Batched Edit)\n\n```\n1. Edit file to:\n   - Fix import\n   - Fix type annotation\n   - Fix unused variable\n   - Add missing parameter\n```\n\n## When to Batch\n\n- **TypeScript/compilation errors**: Fix all errors in a file in one edit\n- **Linting issues**: Address all lint warnings in one edit\n- **Related changes**: If changes are in the same file and related, batch them\n\n## When NOT to Batch\n\n- **Different files**: Each file needs its own edit\n- **Unrelated changes**: If fixing a bug AND adding a feature, do them separately\n- **Testing between changes**: If you need to test after each change\n\n## Example\n\nIf you see 5 TypeScript errors in `user.service.ts`:\n\n1. Read the file once\n2. Identify ALL the issues\n3. Make ONE edit that fixes all 5 errors\n4. Then run the type check\n\nThis saves tool calls and is more efficient.",
        "## Encapsulation\n\n### Module Guidelines\n\n1. **Small and Specific**: Focused modules, not large ones\n2. **Single Responsibility**: Each module owns its providers/controllers\n3. **No Sharing**: Providers belong to only one module\n4. **Import for Use**: Import entire module to use its providers\n5. **Explicit Exports**: Export only what other modules need\n\n```typescript\n@Module({\n  imports: [ManagerModule, OtherModule],\n  controllers: [EntitiesController],\n  providers: [EntitiesProvider, EntitiesService, EntitiesRepository],\n  exports: [EntitiesProvider, EntitiesService],\n})\nexport class EntitiesModule {}\n```",
        "## Error Handling and Logging\n\n### Error Handling Rules\n\n**ONLY Providers use try-catch blocks:**\n\n- Providers are the **ONLY** layer that catches errors\n- All other layers (Services, Repositories, Helpers, Utils) let errors propagate up\n- Never use try-catch in: Controllers, Services, Repositories, Helpers, or Utils\n\n**Why?**\n\n- Centralized error handling in one place\n- Consistent error responses\n- Easier debugging and monitoring\n- Single source of truth for error transformation\n\n```typescript\n// \u2705 CORRECT: Provider catches errors\n@Injectable()\nexport class EntitiesProvider {\n  async create(dto: CreationDto): Promise<ResponseDto> {\n    try {\n      const dm = await this.service.create(dto);\n      return this.transformer.transformToDto(dm);\n    } catch (error) {\n      this.logger.error(\"Failed to create entity\", error);\n      throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n}\n\n// \u2705 CORRECT: Service lets errors propagate\n@Injectable()\nexport class EntitiesService {\n  async create(dm: EntityDm): Promise<EntityDm> {\n    const entity = await this.repository.save(dm); // Errors propagate up\n    return entity;\n  }\n}\n\n// \u274c INCORRECT: Service should NOT catch errors\n@Injectable()\nexport class EntitiesService {\n  async create(dm: EntityDm): Promise<EntityDm> {\n    try {\n      const entity = await this.repository.save(dm);\n      return entity;\n    } catch (error) {\n      // DON'T DO THIS\n      throw error;\n    }\n  }\n}\n```\n\n### Logging Rules\n\n**ONLY Controllers and Providers log:**\n\n- **Controllers**: Log request metadata (user ID, endpoint, params)\n- **Providers**: Log business events, operations, and errors\n- **Services, Repositories, Helpers, Utils**: NO logging\n\n**Why?**\n\n- Avoid duplicate logs\n- Clear separation of concerns\n- Controllers track requests, Providers track business logic\n- Keep Services, Repositories, Helpers, and Utils pure and reusable\n\n```typescript\n// \u2705 CORRECT: Controller logs request metadata\n@Controller(\"/api/v1/entities\")\nexport class EntitiesController {\n  constructor(\n    private readonly provider: EntitiesProvider,\n    private readonly logger: LoggerService,\n  ) {}\n\n  @Post()\n  async create(\n    @Req() req: Request,\n    @Body() dto: CreationDto,\n  ): Promise<ResponseDto> {\n    const user = RequestHelper.getKelaUser(req);\n    this.logger.log(\"Create entity request\", {\n      userId: user.id,\n      endpoint: \"/api/v1/entities\",\n    });\n    return await this.provider.create(dto, user);\n  }\n}\n\n// \u2705 CORRECT: Provider logs business operations and errors\n@Injectable()\nexport class EntitiesProvider {\n  constructor(\n    private readonly service: EntitiesService,\n    private readonly logger: LoggerService,\n  ) {}\n\n  async create(\n    dto: CreationDto,\n    user: KelaUserInterface,\n  ): Promise<ResponseDto> {\n    try {\n      this.logger.log(\"Creating entity\", {\n        userId: user.id,\n        entityName: dto.name,\n      });\n      const dm = await this.service.create(dto);\n      this.logger.log(\"Entity created successfully\", { entityId: dm.id });\n      return Transformer.transformDmToResponseDto(dm);\n    } catch (error) {\n      this.logger.error(\"Failed to create entity\", {\n        error: error.message,\n        userId: user.id,\n      });\n      throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n}\n\n// \u274c INCORRECT: Service should NOT log\n@Injectable()\nexport class EntitiesService {\n  constructor(\n    private readonly repository: EntitiesRepository,\n    private readonly logger: LoggerService, // DON'T inject logger in services\n  ) {}\n\n  async create(dm: EntityDm): Promise<EntityDm> {\n    this.logger.log(\"Saving entity\"); // DON'T DO THIS\n    return await this.repository.save(dm);\n  }\n}\n```",
        "## Complete Flows\n\n### Request Flow\n\n```\nClient Request\n    \u2193\nController (receives DTO)\n    \u2193\nProvider (transforms DTO \u2192 DM)\n    \u2193\nService (transforms DM \u2192 Model)\n    \u2193\nRepository (saves Model to DB)\n    \u2193\nRepository (returns Model)\n    \u2193\nService (transforms Model \u2192 DM)\n    \u2193\nProvider (transforms DM \u2192 Response DTO)\n    \u2193\nController (returns Response DTO)\n    \u2193\nClient Response\n```",
        "# Folder Structure & Scoping Rules\n\n## 1. Modules Directory\n\nAll feature modules MUST be located inside the `src/modules` directory.\n**Never** create feature modules directly in the `src` root.\n\n### Example\n\n\u2705 `src/modules/auth`\n\u2705 `src/modules/users`\n\u274c `src/auth`\n\u274c `src/users`\n\n## 2. Module Internal Structure\n\nEvery module must follow a strict folder breakdown for its components. Do not group files loosely in the module root.\n\n```\nsrc/modules/<module-name>/\n\u251c\u2500\u2500 controllers/       # *.controller.ts\n\u251c\u2500\u2500 providers/         # *.provider.ts\n\u251c\u2500\u2500 services/          # *.service.ts\n\u251c\u2500\u2500 repositories/      # *.repository.ts\n\u251c\u2500\u2500 models/            # *.entity.ts (Database Entities)\n\u251c\u2500\u2500 dms/               # *.dm.ts (Domain Models)\n\u251c\u2500\u2500 dtos/              # *.dto.ts\n\u251c\u2500\u2500 transformers/      # *.transformer.ts\n\u251c\u2500\u2500 helpers/           # *.helper.ts\n\u251c\u2500\u2500 utils/             # *.utils.ts\n\u2514\u2500\u2500 <module-name>.module.ts\n```\n\n## 3. Entity/Model Scoping\n\n**Rule**: Entities (Database Models) must ALWAYS be created within the `models` folder of their owning module.\n**Constraint**: Never create entities in shared folders or outside the specific module scope that owns the data.\n\n## 4. Cross-Module Imports\n\n- Use relative imports when importing within the same module (e.g., `../../dtos/my.dto`).\n- Use absolute imports (from `src`) when importing from other modules or shared kernels.\n\n## 5. Shared/Common Module\n\nGlobal or shared code that is used across multiple modules MUST be placed in `src/common` following this structure:\n\n```\nsrc/common/\n\u251c\u2500\u2500 decorators/        # *.decorator.ts\n\u251c\u2500\u2500 filters/           # *.filter.ts\n\u251c\u2500\u2500 guards/            # *.guard.ts\n\u251c\u2500\u2500 interceptors/      # *.interceptor.ts\n\u251c\u2500\u2500 middleware/        # *.middleware.ts\n\u251c\u2500\u2500 pipes/             # *.pipe.ts\n\u2514\u2500\u2500 strategies/        # *.strategy.ts\n```",
        "# Glossary\n\n**DTO (Data Transfer Object)**: Objects transferred between services or client-server. Must use class-validator and @ApiProperty decorators. Separate into Template, Request, and Response DTOs, Used in Controller and provider layers.\n\n**DM (Data Model)**: Objects for business logic operations before database storage or API response. No validation decorators. Used in service layer.\n\n**Model/Entity**: Database representation with ORM decorators (@Entity, @Column, etc.) used in repository layer.\n\n**Interface**: Type definitions for function parameters, query parameters, and configurations.\n\n**Transformer**: Utility class for converting between DTOs, DMs, Models using static methods.\n\n**Controller**: Entry point for requests. Handles routing and validation only. Works with DTOs. NO error handling (try-catch).\n\n**Provider**: Orchestrates business logic by aggregating services. ONLY place for error handling (try-catch). Logs business events and errors. Transforms DTOs \u2194 DMs.\n\n**Service**: Handles CRUD operations. Transforms DMs \u2194 Models. Simple, reusable functions. NO error handling.\n\n**Repository**: Direct interface to data sources (databases, APIs, queues). Works with Models only. NO error handling. NO logging.\n\n**Manager**: Cross-project reusable modules (HTTP, Elasticsearch, queues).\n\n**Helper**: Encapsulates complex, reusable domain-specific logic.\n\n**Utils**: Simple, common operations (date formatting, string manipulation).",
        "### Helper\n\n**Responsibilities**: Complex, reusable domain-specific logic.\n\n**Use Cases**: Build complex queries, aggregate data, process collections.\n\n**Guidelines**:\n\n- Static methods only\n- Pure functions when possible\n- **NO Error Handling**: Never use try-catch blocks - let errors propagate to provider\n- **NO Logging**: Helpers should not contain any logging logic\n\n```typescript\nexport class WorkspaceHelper {\n  static extractUniqueOwners(workspaces: WorkspaceDm[]): OwnerDm[] {\n    // Complex extraction and deduplication logic\n  }\n}\n```",
        "### Model (Database Entity)\n\n**Requirements**:\n\n- Location: MUST be placed in `src/modules/<module>/models/`\n- ORM decorators (@Entity, @Column, @PrimaryGeneratedColumn)\n- Matches database schema exactly\n\n```typescript\nEntity('assets', { schema: 'control' })\n@Unique(['case_id', 'unique_hash'])\nexport class AssetsEntity {\n@PrimaryGeneratedColumn('uuid')\nid: string;\n\n@Column({ type: 'uuid', name: 'case_id' })\ncase_id: string;\n\n@Column({ type: 'enum', enum: AssetTypeEnum })\ntype: AssetTypeEnum;\n\n@Column({ type: 'varchar', length: 512 })\nvalue: string;\n```",
        "## Naming Conventions\n\n### File Naming\n\n**Format**: `<name>.<type>.<extension>` in **kebab-case**\n\n- Controller: `assets-inventory-sync.controller.ts`\n- Provider: `assets-inventory.provider.ts`\n- Service: `workspace.service.ts`\n- Repository: `inventory.repository.ts`\n- Transformer: `workspace.transformer.ts`\n- DTO: `creation-entity.dto.ts`\n- DM: `entity.dm.ts`\n- Entity: `entity.entity.ts`\n- Interface: `query.interface.ts`\n- Utils: `date.utils.ts`\n- Helper: `workspace.helper.ts`\n- Decorator: `user.decorator.ts`\n- Guard: `roles.guard.ts`\n- Interceptor: `logging.interceptor.ts`\n- Filter: `http-exception.filter.ts`\n- Middleware: `logger.middleware.ts`\n- Pipe: `validation.pipe.ts`\n- Strategy: `jwt.strategy.ts`\n\n### Function Naming\n\n**Format**: `<verb><Entity><Specification?>` in **camelCase**\n\n- `transformDtoToDm()`\n- `getThreatActorById()`\n- `createPlaybook()`\n- `updateAssetStatus()`\n- `extractUniqueOwners()`\n- `determineInventoriesToDisable()`\n\n### Variable Naming\n\n**Style**: **camelCase**\n\n- Use plural for arrays: `inventories`, `workspaces`\n- Include type suffix: `threatActorDm`, `geographyDtos`\n- Descriptive names: `activeInventories`, `workspacesForOwner`\n\n### Constant Naming\n\n**Style**: **UPPER_CASE**\n\n- `IOCS_CSV_HEADERS`\n- `MAX_RETRY_ATTEMPTS`\n- `API_VERSION`\n\n### Class Naming\n\n**Style**: **PascalCase** with type suffix\n\n- `AssetsInventorySyncController`\n- `AssetsInventoryProvider`\n- `WorkspaceService`\n- `InventoriesHelper`\n- `DateUtils`\n- `UserDecorator`\n- `RolesGuard`\n- `LoggingInterceptor`\n- `HttpExceptionFilter`\n- `LoggerMiddleware`\n- `ValidationPipe`\n- `JwtStrategy`\n\n### Interface Naming\n\n**Style**: **PascalCase** with `Interface` suffix\n\n- `KelaUserInterface`\n- `AssetContainersQueryInterface`",
        "# Plan Before Implementing\n\n## For Complex Features (3+ Files)\n\nBefore writing any code, follow this process:\n\n### 1. **Understand the Architecture**\n\n- Read related existing files to understand patterns\n- Check the folder structure to see where things belong\n- Look for similar features to use as reference\n\n### 2. **Create a Plan**\n\nList out:\n\n- Files you'll need to create\n- Files you'll need to modify\n- Order of implementation (dependencies first)\n\n### 3. **Verify Your Plan**\n\n- Does it follow the project structure?\n- Does it match existing patterns?\n- Are you missing any files (DTOs, tests, etc.)?\n\n### 4. **Implement Incrementally**\n\n- Create/modify files in dependency order\n- Test after each major step\n- Fix errors before moving to the next file\n\n## Example: Adding a New API Endpoint\n\n### \u274c Bad Approach\n\n```\n1. Create controller\n2. Get errors about missing service\n3. Create service\n4. Get errors about missing repository\n5. Create repository\n6. Get errors about missing entity\n7. Create entity\n8. Go back and fix everything\n```\n\n### \u2705 Good Approach\n\n```\n1. Plan: Need entity \u2192 repository \u2192 service \u2192 controller \u2192 DTO\n2. Create entity (no dependencies)\n3. Create repository (depends on entity)\n4. Create service (depends on repository)\n5. Create DTOs (independent)\n6. Create controller (depends on service + DTOs)\n7. Run build & tests\n8. Fix any issues\n```\n\n## When to Skip Planning\n\nFor simple tasks (1-2 files, clear requirements), you can skip formal planning:\n\n- Fixing a typo\n- Adding a single function\n- Updating documentation\n- Simple bug fixes\n\n## Benefits\n\n- **Fewer errors** - Dependencies are in place before you need them\n- **Fewer tool calls** - Less back-and-forth fixing missing imports\n- **Better code** - You understand the full picture before implementing\n- **Faster completion** - Less rework and debugging",
        "# NestJS Project Initialization\n\nWhen creating a **new** NestJS application, you MUST follow these steps to ensure a standard, robust starting point.\n\n## 1. Use the Nest CLI Generator\n\n**Do NOT** manually create files and folders for the initial setup. Use the `@nestjs/cli` to generate the scaffold.\n\n### CRITICAL: Use the generator to CREATE the directory\n\nThe NestJS CLI should CREATE the backend directory itself. Do NOT create the directory first.\n\n**From the project root (NOT inside backend/):**\n\n```bash\n# Let the NestJS CLI create the 'backend' directory\nnpx @nestjs/cli new backend --skip-git --package-manager npm\n```\n\nThis creates a `backend/` folder with all NestJS files properly scaffolded.\n\n### If backend directory already exists\n\nIf the backend directory already exists and is empty, remove it first:\n\n```bash\nrmdir backend  # Only works if empty\nnpx @nestjs/cli new backend --skip-git --package-manager npm\n```\n\n### If backend directory has files (rare - avoid this situation)\n\n```bash\n# Remove and recreate\nrm -rf backend\nnpx @nestjs/cli new backend --skip-git --package-manager npm\n```\n\n**NEVER use temp directories and move files** - this causes macOS resource fork issues.\n\n## 2. Enforce Node Version\n\nAfter scaffolding, navigate into the folder and set Node version:\n\n```bash\ncd backend\necho \"v25\" > .nvmrc\n```\n\n## 3. Post-Generation Steps\n\n```bash\nnpm install\nnpm run build  # Verify the setup works\n```\n\n## 4. Package Version Rules\n\n- **NEVER** specify explicit version numbers in package.json\n- Use `@latest` when installing packages: `npm install some-package@latest`\n- Let npm resolve compatible versions automatically\n\n**DO NOT**:\n- Create the `backend` directory before running the generator\n- Use temp directories and move files\n- Specify explicit version numbers like `^11.0.0`\n\n## 2. Enforce Node Version\n\nImmediately after scaffolding, enforce the Node.js version:\n\n```bash\necho \"v25\" > .nvmrc\n```\n\n## 3. Post-Generation Cleanup\n\n- Remove the default `app.controller.spec.ts` if you plan to write more comprehensive e2e tests later.\n- Ensure `tsconfig.json` matches your project strictness requirements.",
        "### Provider\n\n**Responsibilities**: Transform DTOs \u2194 DMs, orchestrate services, implement business logic, handle errors.\n\n**Guidelines**:\n\n- Transform DTO to DM at entry\n- Call multiple services if needed\n- Transform DM to Response DTO before return\n- **Error Handling**: ONLY place to use try-catch blocks\n- **Logging**: Log business events, errors, and important operations\n\n```typescript\n@Injectable()\nexport class EntitiesProvider {\n  constructor(\n    private readonly service: EntitiesService,\n    private readonly logger: LoggerService,\n  ) {}\n\n  async create(\n    dto: CreationDto,\n    user: KelaUserInterface,\n  ): Promise<ResponseDto> {\n    try {\n      this.logger.log(\"Creating entity\", { userId: user.id });\n      const dm: EntityDm = Transformer.transformDtoToDm(dto);\n      const newDm: EntityDm = await this.service.create(dm);\n      return Transformer.transformDmToResponseDto(newDm);\n    } catch (error) {\n      this.logger.error(\"Failed to create entity\", error.message);\n      throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n}\n```",
        "### Repository\n\n**Responsibilities**: Database operations only. Return raw entities.\n\n**Guidelines**:\n\n- Minimal, data-focused functions\n- if making request to an other service, third patry, you can use dto\n- Model-only operations\n- No business logic\n- **NO Error Handling**: Never use try-catch blocks - let errors propagate to provider\n- **NO Logging**: Repositories should not contain any logging logic\n- **Query Building**: Use `<Entity>QueryHelper` for building complex queries. The helper should contain static methods to apply filters, pagination, etc.\n\n```typescript\n@Injectable()\nexport class EntitiesRepository {\n  constructor(\n    @InjectRepository(EntityEntity)\n    private readonly repo: Repository<EntityEntity>,\n  ) {}\n\n  async create(entity: EntityEntity): Promise<EntityEntity> {\n    return await this.repo.save(entity);\n  }\n\n  async findById(id: string): Promise<EntityEntity> {\n    return await this.repo.findOne({ where: { id } });\n  }\n\n  async findByFilters(filters: EntityFilters): Promise<EntityEntity[]> {\n    const queryBuilder = this.repo.createQueryBuilder(\"entity\");\n    EntityQueryHelper.buildQuery(queryBuilder, filters);\n    return await queryBuilder.getMany();\n  }\n}\n```",
        "### Service\n\n**Responsibilities**: CRUD operations, transform DMs \u2194 Models, call repositories.\n\n**Guidelines**:\n\n- Simple, focused functions\n- Transform DM to Model before repository\n- Transform Model to DM after repository\n- No complex business logic\n- **NO Error Handling**: Never use try-catch blocks - let errors propagate to provider\n- **NO Logging**: Services should not contain any logging logic\n\n```typescript\n@Injectable()\nexport class EntitiesService {\n  constructor(private readonly repository: EntitiesRepository) {}\n\n  async create(dm: EntityDm): Promise<EntityDm> {\n    const entity: EntityEntity = Transformer.transformDmToEntity(dm);\n    const newEntity: EntityEntity = await this.repository.create(entity);\n    return Transformer.transformEntityToDm(newEntity);\n  }\n}\n```",
        "## Summary\n\n**Folder Structure**: All modules must be under `src/modules/`.\n**Entity Scoping**: all entities must be inside `models` folder of the specific module.\n\n```\nController (DTO)\n    \u2193\nProvider (DTO \u2194 DM, business logic)\n    \u2193\nService (DM \u2194 Model, CRUD)\n    \u2193\nRepository (Model, database)\n```\n\n**Key Principles**:\n\n- Controllers: Routing + validation only (can log request metadata)\n- Providers: Business logic orchestration + ONLY place for error handling (try-catch) + logging\n- Services: Simple CRUD operations (NO error handling, NO logging)\n- Repositories: Database operations only (NO error handling, NO logging)\n- Transformers: All data conversions\n- Helpers: Complex domain logic (NO error handling, NO logging)\n- Utils: Simple common operations (NO error handling, NO logging)\n\n**Data Flow**: Request DTO \u2192 DM (business) \u2192 Model (database) \u2192 DM \u2192 Response DTO\n\n**Error Handling & Logging**:\n\n- Error Handling (try-catch): ONLY in Providers\n- Logging: ONLY in Controllers (request metadata) and Providers (business events & errors)",
        "### Transformer\n\n**Responsibilities**: Convert between DTOs, DMs, and Models.\n\n**Guidelines**:\n\n- Static methods only\n- Naming: `transform<Source>To<Target>`\n- Centralize all conversions\n\n```typescript\nexport class EntitiesTransformer {\n  static transformDtoToDm(dto: CreationDto): EntityDm {\n    return { name: dto.name, description: dto.description };\n  }\n\n  static transformDmToResponseDto(dm: EntityDm): ResponseDto {\n    return { id: dm.id, name: dm.name, createdAt: dm.createdAt };\n  }\n\n  static transformDmToEntity(dm: EntityDm): EntityEntity {\n    const entity = new EntityEntity();\n    entity.name = dm.name;\n    return entity;\n  }\n\n  static transformEntityToDm(entity: EntityEntity): EntityDm {\n    return { id: entity.id, name: entity.name };\n  }\n}\n```",
        "### Utils\n\n**Responsibilities**: Simple, common operations.\n\n**Use Cases**: Date formatting, string manipulation, calculations.\n\n**Guidelines**:\n\n- Static methods only\n- Pure functions when possible\n- **NO Error Handling**: Never use try-catch blocks - let errors propagate to provider\n- **NO Logging**: Utils should not contain any logging logic\n\n```typescript\nexport class DateUtils {\n  static transformEpochToDate(epoch: number): Date {\n    return moment(epoch * 1000).toDate();\n  }\n}\n```"
      ],
      "rules_dirs": [],
      "rules_files": [],
      "tech": [
        "typescript",
        "nest"
      ],
      "branch_strategy": "hybrid",
      "base_branch": "agent/backend",
      "model": "deepseek-chat",
      "provider": "deepseek",
      "token_budget": null,
      "max_sessions": null,
      "execution_mode": "sdk",
      "task": null,
      "wait_for_pending": false,
      "execution_phase": 1,
      "agent_type": "backend",
      "workspace_dir": "backend",
      "repo_url": null
    },
    {
      "id": "frontend",
      "system_prompt": "You are a frontend engineer. Build React components, pages, and UI based on the feature list. Ensure responsive design and accessibility.\n\nPROJECT INITIALIZATION RULES:\n- For Vite/React: Run 'npm create vite@latest frontend -- --template react-ts' FROM THE PROJECT ROOT - let the CLI create the directory\n- NEVER create the frontend directory first - let the generator create it\n- NEVER use temp directories and move files\n- After scaffolding: cd frontend && npm install && npm run build\n- Use @latest for package versions, NEVER specify explicit version numbers",
      "rules": [
        "# Code Quality Standards\n\n## General Principles\n\n1. **Write code that is easy to read and maintain**\n2. **Follow the project's existing patterns**\n3. **Prefer clarity over cleverness**\n4. **Handle errors explicitly**\n\n## Naming Conventions\n\n### Variables and Functions\n\n```typescript\n// \u2705 Good - Clear, descriptive names\nconst userProfile = getUserProfile(userId);\nconst isAuthenticated = checkAuthStatus();\nconst totalPrice = calculateOrderTotal(items);\n\n// \u274c Bad - Unclear, abbreviated names\nconst up = getUP(uid);\nconst auth = chkAuth();\nconst tot = calc(itms);\n```\n\n### Constants\n\n```typescript\n// \u2705 Good - UPPER_SNAKE_CASE for true constants\nconst MAX_RETRY_ATTEMPTS = 3;\nconst API_BASE_URL = \"https://api.example.com\";\nconst DEFAULT_TIMEOUT_MS = 5000;\n\n// \u2705 Good - camelCase for config objects\nconst apiConfig = {\n  baseUrl: \"https://api.example.com\",\n  timeout: 5000,\n};\n```\n\n### Classes and Interfaces\n\n```typescript\n// \u2705 Good - PascalCase, descriptive\nclass UserAuthenticationService {}\ninterface UserProfile {}\ntype ApiResponse<T> = { data: T; status: number };\n\n// \u274c Bad\nclass userauth {}\ninterface profile {}\ntype response = any;\n```\n\n## Error Handling\n\n### Always Handle Errors\n\n```typescript\n// \u2705 Good - Explicit error handling\ntry {\n  const data = await fetchUserData(userId);\n  return data;\n} catch (error) {\n  logger.error(\"Failed to fetch user data\", { userId, error });\n  throw new UserDataError(\"Unable to retrieve user data\", { cause: error });\n}\n\n// \u274c Bad - Silent failures\ntry {\n  const data = await fetchUserData(userId);\n  return data;\n} catch (error) {\n  // Silent failure\n}\n\n// \u274c Bad - Generic error handling\ntry {\n  const data = await fetchUserData(userId);\n  return data;\n} catch (error) {\n  console.log(\"Error:\", error);\n}\n```\n\n### Use Proper Error Types\n\n```typescript\n// \u2705 Good - Custom error classes\nclass ValidationError extends Error {\n  constructor(\n    message: string,\n    public field: string,\n  ) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(resource: string, id: string) {\n    super(`${resource} with id ${id} not found`);\n    this.name = \"NotFoundError\";\n  }\n}\n\n// \u274c Bad - Generic errors\nthrow new Error(\"Something went wrong\");\n```\n\n## Type Safety\n\n### Use Explicit Types\n\n```typescript\n// \u2705 Good - Explicit types\ninterface User {\n  id: string;\n  email: string;\n  name: string;\n}\n\nfunction getUser(id: string): Promise<User> {\n  return api.get<User>(`/users/${id}`);\n}\n\n// \u274c Bad - Implicit any\nfunction getUser(id) {\n  return api.get(`/users/${id}`);\n}\n```\n\n### Avoid 'any'\n\n```typescript\n// \u2705 Good - Proper typing\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\nfunction handleResponse<T>(response: ApiResponse<T>): T {\n  if (response.status !== 200) {\n    throw new Error(response.message);\n  }\n  return response.data;\n}\n\n// \u274c Bad - Using 'any'\nfunction handleResponse(response: any): any {\n  return response.data;\n}\n```\n\n## Code Organization\n\n### Single Responsibility\n\n```typescript\n// \u2705 Good - Each function has one responsibility\nfunction validateEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\nfunction validatePassword(password: string): boolean {\n  return password.length >= 8;\n}\n\nfunction validateUser(user: { email: string; password: string }): boolean {\n  return validateEmail(user.email) && validatePassword(user.password);\n}\n\n// \u274c Bad - Function does too much\nfunction validateUser(user: any): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(user.email)) return false;\n  if (user.password.length < 8) return false;\n  // ... more validation\n  return true;\n}\n```\n\n### Keep Functions Small\n\n```typescript\n// \u2705 Good - Small, focused functions\nfunction calculateTotal(items: CartItem[]): number {\n  const subtotal = calculateSubtotal(items);\n  const tax = calculateTax(subtotal);\n  const shipping = calculateShipping(items);\n  return subtotal + tax + shipping;\n}\n\n// \u274c Bad - Large, complex function\nfunction calculateTotal(items: any[]): number {\n  let total = 0;\n  for (const item of items) {\n    total += item.price * item.quantity;\n    if (item.discount) {\n      total -= item.discount;\n    }\n  }\n  const tax = total * 0.08;\n  total += tax;\n  // ... 50 more lines\n  return total;\n}\n```\n\n## Comments\n\n### When to Comment\n\n```typescript\n// \u2705 Good - Explain WHY, not WHAT\n// Using exponential backoff to avoid overwhelming the API during high traffic\nconst retryDelay = Math.pow(2, attemptNumber) * 1000;\n\n// \u2705 Good - Document complex algorithms\n/**\n * Implements the Luhn algorithm for credit card validation\n * @see https://en.wikipedia.org/wiki/Luhn_algorithm\n */\nfunction validateCreditCard(cardNumber: string): boolean {\n  // Implementation\n}\n\n// \u274c Bad - Stating the obvious\n// Increment counter by 1\ncounter++;\n\n// \u274c Bad - Commented-out code\n// const oldFunction = () => {\n//   // old implementation\n// };\n```\n\n### Use JSDoc for Public APIs\n\n```typescript\n// \u2705 Good - Documented public API\n/**\n * Fetches user profile data from the API\n * @param userId - The unique identifier for the user\n * @returns Promise resolving to the user profile\n * @throws {NotFoundError} If user doesn't exist\n * @throws {NetworkError} If API request fails\n */\nasync function getUserProfile(userId: string): Promise<UserProfile> {\n  // Implementation\n}\n```\n\n## Clean Code Practices\n\n### No Debug Code in Production\n\n```typescript\n// \u274c Bad - Debug code left in\nconsole.log(\"User data:\", userData);\ndebugger;\nconsole.trace(\"Execution path\");\n\n// \u2705 Good - Use proper logging\nlogger.debug(\"User data retrieved\", { userId: userData.id });\n```\n\n### No Magic Numbers\n\n```typescript\n// \u274c Bad - Magic numbers\nif (user.age > 18) {\n  // ...\n}\nsetTimeout(callback, 3000);\n\n// \u2705 Good - Named constants\nconst LEGAL_AGE = 18;\nconst DEBOUNCE_DELAY_MS = 3000;\n\nif (user.age > LEGAL_AGE) {\n  // ...\n}\nsetTimeout(callback, DEBOUNCE_DELAY_MS);\n```\n\n### Use Modern JavaScript/TypeScript\n\n```typescript\n// \u2705 Good - Modern syntax\nconst userNames = users.map((user) => user.name);\nconst activeUsers = users.filter((user) => user.isActive);\nconst { id, email } = user;\n\n// \u274c Bad - Old syntax\nconst userNames = [];\nfor (let i = 0; i < users.length; i++) {\n  userNames.push(users[i].name);\n}\n```\n\n## Testing\n\n### Write Testable Code\n\n```typescript\n// \u2705 Good - Testable, dependency injection\nclass UserService {\n  constructor(\n    private api: ApiClient,\n    private logger: Logger,\n  ) {}\n\n  async getUser(id: string): Promise<User> {\n    return this.api.get(`/users/${id}`);\n  }\n}\n\n// \u274c Bad - Hard to test, tight coupling\nclass UserService {\n  async getUser(id: string): Promise<User> {\n    return fetch(`https://api.example.com/users/${id}`).then((r) => r.json());\n  }\n}\n```\n\n### Test Coverage\n\n```typescript\n// \u2705 Good - Test happy path and edge cases\ndescribe(\"validateEmail\", () => {\n  it(\"should return true for valid email\", () => {\n    expect(validateEmail(\"user@example.com\")).toBe(true);\n  });\n\n  it(\"should return false for invalid email\", () => {\n    expect(validateEmail(\"invalid\")).toBe(false);\n  });\n\n  it(\"should return false for empty string\", () => {\n    expect(validateEmail(\"\")).toBe(false);\n  });\n\n  it(\"should return false for null\", () => {\n    expect(validateEmail(null as any)).toBe(false);\n  });\n});\n```\n\n## Performance\n\n### Avoid Unnecessary Computation\n\n```typescript\n// \u2705 Good - Memoization for expensive operations\nconst memoizedCalculation = useMemo(() => {\n  return expensiveCalculation(data);\n}, [data]);\n\n// \u274c Bad - Recalculating on every render\nconst result = expensiveCalculation(data);\n```\n\n### Use Appropriate Data Structures\n\n```typescript\n// \u2705 Good - O(1) lookup with Set\nconst userIds = new Set(users.map((u) => u.id));\nconst hasUser = userIds.has(targetId);\n\n// \u274c Bad - O(n) lookup with Array\nconst userIds = users.map((u) => u.id);\nconst hasUser = userIds.includes(targetId);\n```\n\n## Security\n\n### Never Trust User Input\n\n```typescript\n// \u2705 Good - Validate and sanitize\nfunction createUser(input: unknown): User {\n  const validated = userSchema.parse(input); // Zod validation\n  const sanitized = sanitizeUserInput(validated);\n  return repository.create(sanitized);\n}\n\n// \u274c Bad - Direct use of user input\nfunction createUser(input: any): User {\n  return repository.create(input);\n}\n```\n\n### Avoid Sensitive Data in Logs\n\n```typescript\n// \u2705 Good - Redact sensitive data\nlogger.info(\"User login\", {\n  userId: user.id,\n  email: user.email.replace(/(?<=.{2}).*(?=@)/, \"***\"),\n});\n\n// \u274c Bad - Logging sensitive data\nlogger.info(\"User login\", {\n  userId: user.id,\n  email: user.email,\n  password: user.password,\n});\n```\n\n## Summary\n\n**Always:**\n\n- Use descriptive names\n- Handle errors explicitly\n- Use proper types\n- Keep functions small and focused\n- Write tests\n- Remove debug code\n\n**Never:**\n\n- Use 'any' type (unless absolutely necessary)\n- Leave console.log statements\n- Ignore errors\n- Use magic numbers\n- Write untestable code\n- Log sensitive data",
        "# Communication Rules\n\n## Be Concise and Action-Oriented\n\n### \u274c Don't Do This\n\n```\nAgent: \"I'm going to read the file to understand its structure, then I'll analyze\nthe imports to see what dependencies it has, and after that I'll look at the\nimplementation to understand how it works, and then I'll make the changes you\nrequested, and finally I'll test it to make sure everything works correctly.\"\n```\n\n### \u2705 Do This\n\n```\nAgent: [Read] src/components/Button.tsx\nAgent: [Edit] src/components/Button.tsx - Added onClick handler\nAgent: [Test] npm test Button.test.tsx\nAgent: \u2705 Complete\n```\n\n## Progress Indicators\n\nUse clear, scannable progress indicators:\n\n### For Tool Calls\n\n```\n[Tool: Read] src/file.ts\n[Tool: Edit] src/file.ts\n[Tool: Bash] npm run build\n   [Done]\n```\n\n### For Multi-Step Tasks\n\n```\n[Progress] 1/5: Reading existing code\n[Progress] 2/5: Implementing feature\n[Progress] 3/5: Writing tests\n[Progress] 4/5: Running build\n[Progress] 5/5: Verification complete\n```\n\n### For Errors\n\n```\n[Error] Build failed: Cannot find module 'recharts'\n[Fix] Installing recharts...\n[Retry] Running build...\n[Done] Build successful\n```\n\n## Status Updates\n\n### Keep It Brief\n\n**Bad:**\n\n```\n\"I've successfully completed the implementation of the user authentication\nfeature including all the necessary components, services, and tests. The\nfeature now supports login, logout, and session management.\"\n```\n\n**Good:**\n\n```\n\u2705 User authentication complete\n   - Login/logout implemented\n   - Session management added\n   - Tests passing\n```\n\n### Use Structured Output\n\n```\nACTION: edit\nTARGET: src/auth/auth.service.ts\nRESULT: Added JWT token validation\n```\n\n## Error Reporting\n\n### Be Specific\n\n**Bad:**\n\n```\n\"There's an error in the build\"\n```\n\n**Good:**\n\n```\n[Error] Build failed\nType: TypeScript compilation error\nFile: src/components/Chart.tsx:15\nIssue: Cannot find module 'recharts'\nFix: Installing missing dependency\n```\n\n## Asking for Clarification\n\n### When Requirements Are Unclear\n\n**Bad:**\n\n```\n\"I don't understand what you want me to do\"\n```\n\n**Good:**\n\n```\n[Clarification Needed]\nTask: \"Add user preferences\"\nQuestions:\n  1. Where should preferences be stored? (localStorage/database)\n  2. What preferences should be supported?\n  3. Should there be a UI for editing preferences?\n\nProceeding with assumption: localStorage + basic theme preference\nWill adjust if needed.\n```\n\n## Token Efficiency\n\n### Don't Repeat File Contents\n\n**Bad:**\n\n```\nAgent: \"I read the file and it contains:\n[500 lines of code]\nNow I'll make this change...\"\n```\n\n**Good:**\n\n```\nAgent: [Read] src/file.ts\nAgent: [Edit] src/file.ts - Updated line 45\n```\n\n### Don't Explain Unless Asked\n\n**Bad:**\n\n```\n\"I'm using the useState hook here because React requires us to use hooks for\nstate management in functional components, and useState is the most appropriate\nhook for this use case because...\"\n```\n\n**Good:**\n\n```\n[Edit] src/Component.tsx - Added state management\n```\n\n### Summarize, Don't Repeat\n\n**Bad:**\n\n```\n\"The file exports these functions: function1, function2, function3, function4...\n[lists all 50 functions]\"\n```\n\n**Good:**\n\n```\n[Read] src/utils.ts - 50 utility functions for data transformation\n```\n\n## Decision Documentation\n\n### Record Important Decisions\n\n```\n[DECISION] Using Zod for validation\nReason: Type-safe, composable, better DX than Yup\nImpact: All DTOs will use Zod schemas\n```\n\n### Record Understanding\n\n```\n[UNDERSTOOD] src/auth/auth.service.ts\nPurpose: Handles JWT token generation and validation\nDependencies: jsonwebtoken, bcrypt\n```\n\n## Contracts Communication\n\n### When Implementing APIs\n\n```\n[CONTRACT] POST /api/users\nRequest: { email: string, password: string }\nResponse: { id: string, token: string }\nStatus: Implemented\n```\n\n## Session Boundaries\n\n### At Session Start\n\n```\n[SESSION START]\nTask: Implement user dashboard\nContext: Previous session created API endpoints\nStatus: Ready to build frontend\n```\n\n### At Session End\n\n```\n[SESSION END]\nCompleted:\n  \u2705 Dashboard component\n  \u2705 Data fetching hooks\n  \u2705 Tests passing\n\nRemaining: None\nStatus: COMPLETE\n```\n\n## Formatting Guidelines\n\n### Use Markdown\n\n- **Bold** for emphasis\n- `Code` for file names, commands, code snippets\n- Lists for multiple items\n- Headers for sections\n\n### Use Emojis Sparingly\n\nOnly for status indicators:\n\n- \u2705 Complete/Success\n- \u274c Error/Failed\n- \u23f3 In Progress\n- \ud83d\udd27 Fixing\n- \ud83d\udccb Planning\n\n### Keep Lines Short\n\n- Max 80-100 characters per line\n- Break long messages into bullet points\n- Use whitespace for readability\n\n## Examples\n\n### Good Communication Flow\n\n```\n[Task] Add user profile page\n\n[Read] src/pages/Dashboard.tsx - Understanding routing structure\n[Write] src/pages/Profile.tsx - Created profile component\n[Write] src/hooks/useProfile.ts - Added data fetching hook\n[Edit] src/App.tsx - Added profile route\n\n[Test] npm test Profile\n   [Done] All tests passing\n\n[Verify] npm run build\n   [Done] Build successful\n\n\u2705 User profile page complete\n```\n\n### Bad Communication Flow\n\n```\nOkay, so I'm going to start by reading the dashboard file to understand how\nthe routing works in this application. After I understand that, I'll create\na new profile page following the same pattern. Then I'll need to add a hook\nfor fetching the user data...\n\n[lots of explanation]\n\n...and now I've completed the profile page implementation. It should work\ncorrectly but I haven't tested it yet. Let me know if you want me to test it.\n```\n\n## Summary\n\n**DO:**\n\n- Be concise\n- Use structured output\n- Show progress clearly\n- Report errors specifically\n- Document decisions\n\n**DON'T:**\n\n- Explain unnecessarily\n- Repeat file contents\n- Write long paragraphs\n- Leave status unclear\n- Skip verification",
        "---\ndescription: Rules for implementing UI using the central Design System\npriority: 85\n---\n\n# Implementing Design System\n\n**IF YOU ARE THE FRONTEND AGENT:**\n\nThe visual style of the application is defined centrally in `design_system.json`.\n\n## 1. Do Not Hardcode Colors\n\n\u274c **Incorrect**:\n\n```css\n.button {\n  background-color: #3b82f6;\n}\n```\n\n```jsx\n<div style={{ color: \"red\" }}>Error</div>\n```\n\n\u2705 **Correct**:\nUse utility classes derived from the theme or CSS variables.\n\n```css\n.button {\n  background-color: var(--color-primary);\n}\n```\n\n## 2. Syncing with Design System\n\nWhen you see changes in `design_system.json`:\n\n1.  **Update Tailwind Config**: If using Tailwind, map the `package.json` or `tailwind.config.js` to read from `design_system.json`.\n2.  **Update CSS Variables**: If using plain CSS, update your `:root` definition to match the JSON values.\n\n## 3. Consistency\n\n- Always use the spacing scale defined in the system.\n- Use typography tokens for font sizes and weights.\n- If a new color is needed, ask the Product/Design agent to add it to the system first.",
        "# Error Recovery Rules\n\n## Core Principle: Never Stop on Errors\n\n**YOU MUST FIX ERRORS IMMEDIATELY** - Do not move on to other tasks when you encounter errors.\n\n## Error Categories and Recovery\n\n### 1. Build/Compilation Errors\n\n**Examples:**\n\n- `error TS2307: Cannot find module 'recharts'`\n- `npm ERR! missing dependency`\n- `SyntaxError: Unexpected token`\n\n**Recovery Steps:**\n\n1. Read the full error message\n2. Identify the root cause (missing dependency, syntax error, type error)\n3. Fix immediately:\n   - Missing module \u2192 Install it: `npm install <module>`\n   - Type error \u2192 Add proper types or fix the code\n   - Syntax error \u2192 Fix the syntax\n4. Run build again to verify: `npm run build`\n5. **Do not proceed** until build succeeds\n\n### 2. Test Failures\n\n**Examples:**\n\n- `FAIL src/components/Button.test.tsx`\n- `Expected 200 but got 404`\n- `AssertionError: expected true to be false`\n\n**Recovery Steps:**\n\n1. Read the test failure output\n2. Understand what the test expects\n3. Fix the implementation OR update the test (if requirements changed)\n4. Run tests again: `npm test`\n5. **Do not proceed** until all tests pass\n\n### 3. Type Errors\n\n**Examples:**\n\n- `Type 'string' is not assignable to type 'number'`\n- `Property 'foo' does not exist on type 'Bar'`\n- `Argument of type 'X' is not assignable to parameter of type 'Y'`\n\n**Recovery Steps:**\n\n1. Identify the type mismatch\n2. Fix by:\n   - Adding proper type annotations\n   - Updating interfaces/types\n   - Adding type guards or assertions (only if safe)\n3. Run TypeScript check: `npm run build` or `tsc --noEmit`\n4. **Do not proceed** until type errors are resolved\n\n### 4. Dependency Errors\n\n**Examples:**\n\n- `Cannot find module 'X'`\n- `MODULE_NOT_FOUND`\n- `Package 'X' not found`\n\n**Recovery Steps:**\n\n1. Install the missing dependency: `npm install <package>`\n2. If it's a dev dependency: `npm install -D <package>`\n3. If it's a type definition: `npm install -D @types/<package>`\n4. Verify installation: `npm run build`\n\n### 5. Network/External Errors\n\n**Examples:**\n\n- `ECONNREFUSED`\n- `ETIMEDOUT`\n- `getaddrinfo ENOTFOUND`\n\n**Recovery Steps:**\n\n1. **Do not retry indefinitely** - these are often environmental\n2. Check if the service/API is required for the task\n3. If required: Document the blocker and wait\n4. If optional: Mock the data or skip the external call\n5. **Maximum 2-3 retries** then move on\n\n## Error Recovery Workflow\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Execute Task   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Error?  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n    \u2502  YES    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Read full error \u2502\n\u2502 2. Identify cause  \u2502\n\u2502 3. Fix immediately \u2502\n\u2502 4. Verify fix      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Fixed?  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n    \u2502  YES    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Continue task   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## What NOT to Do\n\n\u274c **Don't ignore errors and continue**\n\n```\n[Error] Cannot find module 'recharts'\nAgent: \"I'll move on to the next feature...\"\n```\n\n\u274c **Don't give up after one attempt**\n\n```\n[Error] Tests failed\nAgent: \"There's a test failure, but I'll document it for later\"\n```\n\n\u274c **Don't create workarounds instead of fixing**\n\n```\n[Error] Type error in function\nAgent: \"I'll use 'any' type to bypass this\"\n```\n\n## What TO Do\n\n\u2705 **Fix immediately**\n\n```\n[Error] Cannot find module 'recharts'\nAgent: \"Installing recharts...\"\n[Tool: Bash] npm install recharts\n[Tool: Bash] npm run build\n[Done] Build successful\n```\n\n\u2705 **Persist until resolved**\n\n```\n[Error] Tests failed\nAgent: \"Analyzing test failure...\"\n[Tool: Read] test file\nAgent: \"Fixing implementation...\"\n[Tool: Edit] source file\n[Tool: Bash] npm test\n[Done] All tests passing\n```\n\n\u2705 **Fix root cause**\n\n```\n[Error] Type error in function\nAgent: \"Adding proper type definition...\"\n[Tool: Edit] types file\n[Tool: Bash] npm run build\n[Done] Type errors resolved\n```\n\n## Session Continuity\n\nIf a session ends with unresolved errors:\n\n1. **Document the error state**:\n\n   ```\n   [SESSION_END_STATE]\n   Status: ERROR\n   Error Type: Build failure\n   Error Message: Cannot find module 'recharts'\n   Next Action: Install recharts and rebuild\n   ```\n\n2. **Next session starts with error context**:\n   - Previous error will be shown\n   - Your FIRST task is to fix it\n   - Do not start new work until error is resolved\n\n## Success Criteria\n\nA task is only complete when:\n\n- \u2705 No build errors\n- \u2705 No test failures\n- \u2705 No type errors\n- \u2705 No lint errors\n- \u2705 Feature requirements met\n\n**If ANY of these fail, you are NOT done.**",
        "# Global Naming Conventions\n\nThese naming conventions apply to ALL agents working within the repository. Agents MUST adhere to these rules based on the programming language they are using.\n\n## General Principles\n\n1.  **Descriptive**: Names should clearly describe the purpose of the file, variable, function, or class.\n2.  **Consistent**: Stick to the defined case styles for each language.\n3.  **No Abbreviations**: Avoid ambiguous abbreviations (e.g., use `user-repository` instead of `user-repo`).\n\n---\n\n## TypeScript / JavaScript (Frontend & Backend)\n\n### File Naming\n\n**Style**: `kebab-case` with type suffix.\n\n- **Format**: `<name>.<type>.<extension>`\n- **Examples**:\n  - `user.controller.ts`\n  - `auth.service.ts`\n  - `user-profile.component.tsx`\n  - `api-response.interface.ts`\n  - `date.utils.ts`\n  - `roles.guard.ts`\n\n### Class Naming\n\n**Style**: `PascalCase` with type suffix.\n\n- **Examples**:\n  - `UserController`\n  - `AuthService`\n  - `UserProfileComponent`\n  - `RolesGuard`\n  - `HttpExceptionFilter`\n\n### Interface Naming\n\n**Style**: `PascalCase`\n\n- **Prefix**: Avoid `I` prefix (e.g., use `User` instead of `IUser`).\n- **Suffix**: Use specific suffixes if helpful (e.g., `UserProps`, `ApiResponse`, `CreateUserDto`).\n- **Examples**:\n  - `UserProfile`\n  - `AuthResponse`\n\n### Function & Method Naming\n\n**Style**: `camelCase`\n\n- **Format**: `<verb><Entity><Specification?>`\n- **Examples**:\n  - `getUserById()`\n  - `validateInput()`\n  - `handleClick()`\n\n### Variable Naming\n\n**Style**: `camelCase`\n\n- **Examples**:\n  - `userData`\n  - `isValid`\n  - `items`\n\n### Constant Naming\n\n**Style**: `UPPER_CASE` with underscores.\n\n- **Examples**:\n  - `MAX_RETRY_ATTEMPTS`\n  - `API_BASE_URL`\n\n---\n\n## Python\n\n### File Naming\n\n**Style**: `snake_case`\n\n- **Format**: `<name>_<type>.<extension>` (where type is part of the name if needed for clarity)\n- **Examples**:\n  - `user_controller.py`\n  - `auth_service.py`\n  - `date_utils.py`\n  - `roles_guard.py` (if implementing similar patterns)\n\n### Class Naming\n\n**Style**: `PascalCase`\n\n- **Examples**:\n  - `UserController`\n  - `AuthService`\n  - `UserProfile`\n\n### Function & Method Naming\n\n**Style**: `snake_case`\n\n- **Format**: `<verb>_<entity>_<specification?>`\n- **Examples**:\n  - `get_user_by_id()`\n  - `validate_input()`\n  - `calculate_total()`\n\n### Variable Naming\n\n**Style**: `snake_case`\n\n- **Examples**:\n  - `user_data`\n  - `is_valid`\n  - `items`\n\n### Constant Naming\n\n**Style**: `UPPER_CASE` with underscores.\n\n- **Examples**:\n  - `MAX_RETRY_ATTEMPTS`\n  - `API_BASE_URL`\n\n---\n\n## Directory Naming (All Languages)\n\n**Style**: `kebab-case` (preferred) or `snake_case` (if strictly Python-only project).\n\n- **Preferred**: `user-management`, `auth-service`, `common-utils`\n- **Python Project Exception**: `user_management` (to ensure valid Python packages/imports)\n\n## Shared/Common Components (Across Languages)\n\nWhen creating shared components (Decorators, Guards, Interceptors, etc.), use the following conventions adapted for the language:\n\n| Component Type       | TypeScript Example (kebab-case) | Python Example (snake_case)                        |\n| :------------------- | :------------------------------ | :------------------------------------------------- |\n| **Controller**       | `user.controller.ts`            | `user_controller.py`                               |\n| **Service**          | `auth.service.ts`               | `auth_service.py`                                  |\n| **Provider**         | `data.provider.ts`              | `data_provider.py`                                 |\n| **Repository**       | `user.repository.ts`            | `user_repository.py`                               |\n| **Model/Entity**     | `user.entity.ts`                | `user_entity.py` (or `models/user.py`)             |\n| **DTO**              | `create-user.dto.ts`            | `create_user_dto.py` (or `schemas/create_user.py`) |\n| **Utils**            | `date.utils.ts`                 | `date_utils.py`                                    |\n| **Guard**            | `roles.guard.ts`                | `roles_guard.py`                                   |\n| **Decorator**        | `user.decorator.ts`             | `user_decorator.py`                                |\n| **Middleware**       | `logger.middleware.ts`          | `logger_middleware.py`                             |\n| **Exception Filter** | `http-exception.filter.ts`      | `http_exception_filter.py`                         |",
        "---\ndescription: Rules for installing and managing dependencies\npriority: 90\n---\n\n# Package Management Rules\n\nTo ensure dependencies are installed correctly and persisted, follow these rules:\n\n## 1. Verify Project Root\n\n**NEVER** run `npm install` blindly. First, verify where the `package.json` file is located:\n\n- If working on backend, it's likely in `./backend/`\n- If working on frontend, it's likely in `./frontend/`\n\n## 2. Change Directory First\n\nAlways change into the project directory before running npm commands.\n\u2705 **CORRECT:**\n\n```bash\ncd backend && npm install recharts\n```\n\n\u274c **INCORRECT:**\n\n```bash\nnpm install recharts\n# Fails because package.json is not in the current root\n```\n\n## 3. Save Dependencies\n\nAlways use appropriate flags to save dependencies to `package.json`.\n\n- production: `npm install <package>` (default saves in modern npm)\n- dev: `npm install --save-dev <package>`\n\n## 4. Verification\n\nAfter installing, ALWAYS verify the installation was successful by:\n\n1. Checking exit code (should be 0)\n2. Checking if the package appears in `package.json`\n3. If checking for types, verify `@types/<package>` is installed if needed.\n\n## Example Recovery\n\nIf you see \"Cannot find module 'X'\", do NOT just run `npm install X`.\n\n1. `ls -R` to find where `package.json` is.\n2. `cd <correct_dir> && npm install X`.\n\n### Docker Permission Errors (EACCES)\n\nIf you see `npm error code EACCES` or `Your cache folder contains root-owned files`:\n**DO NOT** try to use sudo.\n\u2705 **FIX:** Use a local cache directory:\n\n```bash\nnpm install <package> --cache .npm-cache\n```",
        "---\ndescription: Rules for initializing new projects\npriority: 95\n---\n\n# Project Initialization Rules\n\nThese rules apply when **starting a new project/session** or when the specialized agent detects that the project environment is not set up.\n\n## 1. Node Version Management (.nvmrc)\n\nEvery new project MUST enforce the usage of Node.js version 25.\n\n**Rule**:\n\n- Create a `.nvmrc` file in the root of the project (and in `backend/`/`frontend/` if they are separate repos/roots).\n- The content of `.nvmrc` MUST be: `v25`\n\n**Command to verify/create**:\n\n```bash\necho \"v25\" > .nvmrc\n```\n\n**Why**: Using a consistent, modern Node version prevents compatibility issues across different environments and agent sessions.\n\n## 2. Using the Correct Version\n\nWhen running commands, always ensure the environment is using the version specified in `.nvmrc`.\nIf `nvm` is available:\n\n```bash\nnvm use\n```\n\nIf not, assume the standard environment provided to the agent is compatible or try to install/use the specific version if permissions allow.\n\n## 3. Framework Initialization\n\n- **NestJS**: See `skills/nest/rules/project-initialization.md`\n- **React**: See `skills/react-best-practices/rules/project-initialization.md`",
        "# Task Completion Criteria\n\n## Definition of Done\n\nA task is **ONLY COMPLETE** when **ALL** of these criteria are met:\n\n### 1. \u2705 Build Succeeds\n\n```bash\nnpm run build\n# OR\nnpm run build:backend\n# OR\nnpm run build:frontend\n\n# Must complete with EXIT CODE 0 and NO ERRORS\n```\n\n**Not done if:**\n\n- Build exits with errors\n- TypeScript compilation fails\n- Webpack/Vite build fails\n\n### 2. \u2705 All Tests Pass\n\n```bash\nnpm test\n# OR\nnpm run test:unit\n# OR\nnpm run test:e2e\n\n# Must show: 0 failures, all tests passing\n```\n\n**Not done if:**\n\n- Any test fails\n- Tests are skipped (.skip)\n- Tests are marked as .todo\n\n### 3. \u2705 No TypeScript Errors\n\n```bash\ntsc --noEmit\n# OR check build output\n\n# Must show: 0 errors\n```\n\n**Not done if:**\n\n- Type errors exist\n- Imports cannot be resolved\n- Types are missing or incorrect\n- Using 'any' as a workaround\n\n### 4. \u2705 No Lint Errors\n\n```bash\nnpm run lint\n# OR\neslint .\n\n# Must show: 0 errors (warnings are acceptable)\n```\n\n**Not done if:**\n\n- Lint errors exist\n- Unused variables/imports\n- Code style violations\n\n### 5. \u2705 Feature Requirements Met\n\n**Check against the task description:**\n\n- All acceptance criteria addressed\n- Feature works as described\n- Edge cases handled\n- Error cases handled\n\n**Not done if:**\n\n- Only partial implementation\n- Missing edge case handling\n- Incomplete functionality\n\n### 6. \u2705 Code Quality\n\n**Standards:**\n\n- No debug code (console.log, debugger)\n- No commented-out code\n- Proper error handling\n- Clear variable/function names\n- Appropriate comments for complex logic\n\n**Not done if:**\n\n- Debug statements left in\n- Poor naming conventions\n- Missing error handling\n- Unclear code\n\n## Verification Checklist\n\nBefore marking a task complete, run this checklist:\n\n```markdown\n## Task Completion Verification\n\n- [ ] `npm run build` \u2192 \u2705 SUCCESS (exit code 0)\n- [ ] `npm test` \u2192 \u2705 ALL TESTS PASS\n- [ ] `tsc --noEmit` \u2192 \u2705 NO TYPE ERRORS\n- [ ] `npm run lint` \u2192 \u2705 NO LINT ERRORS\n- [ ] All acceptance criteria \u2192 \u2705 MET\n- [ ] Code quality \u2192 \u2705 CLEAN\n- [ ] No debug code \u2192 \u2705 REMOVED\n- [ ] Error handling \u2192 \u2705 IMPLEMENTED\n\n**Status: READY TO COMMIT**\n```\n\n## Common Mistakes\n\n### \u274c Stopping Too Early\n\n**Wrong:**\n\n```\nAgent: \"I created the component files\"\nReality: Files don't compile, imports are broken\n```\n\n**Right:**\n\n```\nAgent: \"I created the component files\"\nAgent: [Runs build]\nAgent: [Fixes import errors]\nAgent: [Runs build again]\nAgent: \"Build successful, component complete\"\n```\n\n### \u274c Ignoring Test Failures\n\n**Wrong:**\n\n```\nAgent: \"Feature implemented\"\n[Tests show 3 failures]\nAgent: \"Moving to next task\"\n```\n\n**Right:**\n\n```\nAgent: \"Feature implemented\"\n[Tests show 3 failures]\nAgent: \"Fixing test failures...\"\n[Fixes implementation]\n[All tests pass]\nAgent: \"Feature complete\"\n```\n\n### \u274c Using Workarounds\n\n**Wrong:**\n\n```\n[Type error]\nAgent: \"I'll use 'any' type to bypass this\"\n```\n\n**Right:**\n\n```\n[Type error]\nAgent: \"Adding proper type definition...\"\n[Creates/updates interface]\n[Type error resolved]\n```\n\n## When You Encounter Errors\n\n**Follow this process:**\n\n1. **Read the FULL error message**\n   - Don't just read the first line\n   - Understand the stack trace\n   - Identify the root cause\n\n2. **Fix the ROOT CAUSE**\n   - Not just the symptom\n   - Not with workarounds\n   - Properly and completely\n\n3. **Verify the fix**\n   - Run the check again\n   - Ensure error is gone\n   - Ensure no new errors introduced\n\n4. **Continue until ALL checks pass**\n   - Don't stop at \"mostly working\"\n   - All criteria must be met\n\n## Progress Tracking\n\n### During Implementation\n\nUpdate your progress clearly:\n\n```\n[PROGRESS]\n\u2705 Created component structure\n\u2705 Implemented core logic\n\u23f3 Writing tests (3/5 complete)\n\u23f3 Fixing type errors (2 remaining)\n\u274c Build not yet successful\n```\n\n### At Session End\n\nIf you can't complete in one session:\n\n```\n[SESSION_END]\nStatus: IN_PROGRESS\nCompleted:\n  \u2705 Component structure\n  \u2705 Core logic\n  \u2705 3/5 tests written\n\nRemaining:\n  \u23f3 2 tests to write\n  \u23f3 2 type errors to fix\n  \u23f3 Build verification\n\nNext Session: Complete remaining tests and fix type errors\n```\n\n## Success Metrics\n\nA well-completed task:\n\n- \u2705 Takes 1-3 sessions (not 10+)\n- \u2705 Passes all checks on first verification\n- \u2705 Has minimal back-and-forth\n- \u2705 Is ready to merge immediately\n- \u2705 Requires no follow-up fixes\n\n## Final Rule\n\n**DO NOT mark a task as complete unless:**\n\n```\nBuild \u2705 AND\nTests \u2705 AND\nTypes \u2705 AND\nLint \u2705 AND\nRequirements \u2705 AND\nQuality \u2705\n```\n\n**If ANY check fails, you are NOT done.**",
        "---\ndescription: Rules for UX/UI Design and Design System Management\npriority: 85\n---\n\n# UX/UI Design Lead Rules\n\n**IF YOU ARE THE PRODUCT AGENT:**\n\nAs the Design Lead, you are responsible for the aesthetic and functional design of the application.\n\n## 1. Single Source of Truth\n\nYou must define and maintain a `design_system.json` file in the project root. This file controls the look and feel of the entire app.\n\n### Format Structure\n\n```json\n{\n  \"theme\": {\n    \"colors\": {\n      \"primary\": \"#...\",\n      \"secondary\": \"#...\",\n      \"background\": \"#...\",\n      \"surface\": \"#...\",\n      \"text\": {\n        \"primary\": \"#...\",\n        \"secondary\": \"#...\"\n      },\n      \"success\": \"#...\",\n      \"error\": \"#...\"\n    },\n    \"typography\": {\n      \"fontFamily\": \"Inter, sans-serif\",\n      \"sizes\": { ... }\n    },\n    \"spacing\": { ... },\n    \"borderRadius\": { ... }\n  }\n}\n```\n\n## 2. Color Selection\n\n- **Harmonious Palettes**: Use color theory (complementary, analogous, etc.) to pick colors that work well together.\n- **Accessibility**: Ensure sufficient contrast between text and background colors (WCAG AA standard).\n- **Vibrant & Modern**: Avoid default HTML colors. Use modern, vibrant colors (e.g., slate, emerald, violet, sky).\n- **Dark/Light Mode**: Consider how colors will look in both modes if applicable.\n\n## 3. Workflow\n\n1.  **Initialize**: If `design_system.json` does not exist, CREATE it immediately with a default modern theme.\n2.  **Iterate**: If the user asks for a color change, UPDATE `design_system.json`. Do not tell the frontend developer to hardcode hex values.\n3.  **Communicate**: When defining features, reference the design tokens (e.g., \"Use the `primary` color for the main action button\").",
        "# Sections\n\nThis file defines all sections, their ordering, impact levels, and descriptions.\nThe section ID (in parentheses) is the filename prefix used to group rules.\n\n---\n\n## 1. Eliminating Waterfalls (async)\n\n**Impact:** CRITICAL  \n**Description:** Waterfalls are the #1 performance killer. Each sequential await adds full network latency. Eliminating them yields the largest gains.\n\n## 2. Bundle Size Optimization (bundle)\n\n**Impact:** CRITICAL  \n**Description:** Reducing initial bundle size improves Time to Interactive and Largest Contentful Paint.\n\n## 3. Server-Side Performance (server)\n\n**Impact:** HIGH  \n**Description:** Optimizing server-side rendering and data fetching eliminates server-side waterfalls and reduces response times.\n\n## 4. Client-Side Data Fetching (client)\n\n**Impact:** MEDIUM-HIGH  \n**Description:** Automatic deduplication and efficient data fetching patterns reduce redundant network requests.\n\n## 5. Re-render Optimization (rerender)\n\n**Impact:** MEDIUM  \n**Description:** Reducing unnecessary re-renders minimizes wasted computation and improves UI responsiveness.\n\n## 6. Rendering Performance (rendering)\n\n**Impact:** MEDIUM  \n**Description:** Optimizing the rendering process reduces the work the browser needs to do.\n\n## 7. JavaScript Performance (js)\n\n**Impact:** LOW-MEDIUM  \n**Description:** Micro-optimizations for hot paths can add up to meaningful improvements.\n\n## 8. Advanced Patterns (advanced)\n\n**Impact:** LOW  \n**Description:** Advanced patterns for specific cases that require careful implementation.",
        "---\ntitle: Rule Title Here\nimpact: MEDIUM\nimpactDescription: Optional description of impact (e.g., \"20-50% improvement\")\ntags: tag1, tag2\n---\n\n## Rule Title Here\n\n**Impact: MEDIUM (optional impact description)**\n\nBrief explanation of the rule and why it matters. This should be clear and concise, explaining the performance implications.\n\n**Incorrect (description of what's wrong):**\n\n```typescript\n// Bad code example here\nconst bad = example()\n```\n\n**Correct (description of what's right):**\n\n```typescript\n// Good code example here\nconst good = example()\n```\n\nReference: [Link to documentation or resource](https://example.com)",
        "---\ntitle: Store Event Handlers in Refs\nimpact: LOW\nimpactDescription: stable subscriptions\ntags: advanced, hooks, refs, event-handlers, optimization\n---\n\n## Store Event Handlers in Refs\n\nStore callbacks in refs when used in effects that shouldn't re-subscribe on callback changes.\n\n**Incorrect (re-subscribes on every render):**\n\n```tsx\nfunction useWindowEvent(event: string, handler: (e) => void) {\n  useEffect(() => {\n    window.addEventListener(event, handler)\n    return () => window.removeEventListener(event, handler)\n  }, [event, handler])\n}\n```\n\n**Correct (stable subscription):**\n\n```tsx\nfunction useWindowEvent(event: string, handler: (e) => void) {\n  const handlerRef = useRef(handler)\n  useEffect(() => {\n    handlerRef.current = handler\n  }, [handler])\n\n  useEffect(() => {\n    const listener = (e) => handlerRef.current(e)\n    window.addEventListener(event, listener)\n    return () => window.removeEventListener(event, listener)\n  }, [event])\n}\n```\n\n**Alternative: use `useEffectEvent` if you're on latest React:**\n\n```tsx\nimport { useEffectEvent } from 'react'\n\nfunction useWindowEvent(event: string, handler: (e) => void) {\n  const onEvent = useEffectEvent(handler)\n\n  useEffect(() => {\n    window.addEventListener(event, onEvent)\n    return () => window.removeEventListener(event, onEvent)\n  }, [event])\n}\n```\n\n`useEffectEvent` provides a cleaner API for the same pattern: it creates a stable function reference that always calls the latest version of the handler.",
        "---\ntitle: Initialize App Once, Not Per Mount\nimpact: LOW-MEDIUM\nimpactDescription: avoids duplicate init in development\ntags: initialization, useEffect, app-startup, side-effects\n---\n\n## Initialize App Once, Not Per Mount\n\nDo not put app-wide initialization that must run once per app load inside `useEffect([])` of a component. Components can remount and effects will re-run. Use a module-level guard or top-level init in the entry module instead.\n\n**Incorrect (runs twice in dev, re-runs on remount):**\n\n```tsx\nfunction Comp() {\n  useEffect(() => {\n    loadFromStorage()\n    checkAuthToken()\n  }, [])\n\n  // ...\n}\n```\n\n**Correct (once per app load):**\n\n```tsx\nlet didInit = false\n\nfunction Comp() {\n  useEffect(() => {\n    if (didInit) return\n    didInit = true\n    loadFromStorage()\n    checkAuthToken()\n  }, [])\n\n  // ...\n}\n```\n\nReference: [Initializing the application](https://react.dev/learn/you-might-not-need-an-effect#initializing-the-application)",
        "---\ntitle: useEffectEvent for Stable Callback Refs\nimpact: LOW\nimpactDescription: prevents effect re-runs\ntags: advanced, hooks, useEffectEvent, refs, optimization\n---\n\n## useEffectEvent for Stable Callback Refs\n\nAccess latest values in callbacks without adding them to dependency arrays. Prevents effect re-runs while avoiding stale closures.\n\n**Incorrect (effect re-runs on every callback change):**\n\n```tsx\nfunction SearchInput({ onSearch }: { onSearch: (q: string) => void }) {\n  const [query, setQuery] = useState('')\n\n  useEffect(() => {\n    const timeout = setTimeout(() => onSearch(query), 300)\n    return () => clearTimeout(timeout)\n  }, [query, onSearch])\n}\n```\n\n**Correct (using React's useEffectEvent):**\n\n```tsx\nimport { useEffectEvent } from 'react';\n\nfunction SearchInput({ onSearch }: { onSearch: (q: string) => void }) {\n  const [query, setQuery] = useState('')\n  const onSearchEvent = useEffectEvent(onSearch)\n\n  useEffect(() => {\n    const timeout = setTimeout(() => onSearchEvent(query), 300)\n    return () => clearTimeout(timeout)\n  }, [query])\n}\n```",
        "---\ntitle: Prevent Waterfall Chains in API Routes\nimpact: CRITICAL\nimpactDescription: 2-10\u00d7 improvement\ntags: api-routes, server-actions, waterfalls, parallelization\n---\n\n## Prevent Waterfall Chains in API Routes\n\nIn API routes and Server Actions, start independent operations immediately, even if you don't await them yet.\n\n**Incorrect (config waits for auth, data waits for both):**\n\n```typescript\nexport async function GET(request: Request) {\n  const session = await auth()\n  const config = await fetchConfig()\n  const data = await fetchData(session.user.id)\n  return Response.json({ data, config })\n}\n```\n\n**Correct (auth and config start immediately):**\n\n```typescript\nexport async function GET(request: Request) {\n  const sessionPromise = auth()\n  const configPromise = fetchConfig()\n  const session = await sessionPromise\n  const [config, data] = await Promise.all([\n    configPromise,\n    fetchData(session.user.id)\n  ])\n  return Response.json({ data, config })\n}\n```\n\nFor operations with more complex dependency chains, use `better-all` to automatically maximize parallelism (see Dependency-Based Parallelization).",
        "---\ntitle: Defer Await Until Needed\nimpact: HIGH\nimpactDescription: avoids blocking unused code paths\ntags: async, await, conditional, optimization\n---\n\n## Defer Await Until Needed\n\nMove `await` operations into the branches where they're actually used to avoid blocking code paths that don't need them.\n\n**Incorrect (blocks both branches):**\n\n```typescript\nasync function handleRequest(userId: string, skipProcessing: boolean) {\n  const userData = await fetchUserData(userId)\n  \n  if (skipProcessing) {\n    // Returns immediately but still waited for userData\n    return { skipped: true }\n  }\n  \n  // Only this branch uses userData\n  return processUserData(userData)\n}\n```\n\n**Correct (only blocks when needed):**\n\n```typescript\nasync function handleRequest(userId: string, skipProcessing: boolean) {\n  if (skipProcessing) {\n    // Returns immediately without waiting\n    return { skipped: true }\n  }\n  \n  // Fetch only when needed\n  const userData = await fetchUserData(userId)\n  return processUserData(userData)\n}\n```\n\n**Another example (early return optimization):**\n\n```typescript\n// Incorrect: always fetches permissions\nasync function updateResource(resourceId: string, userId: string) {\n  const permissions = await fetchPermissions(userId)\n  const resource = await getResource(resourceId)\n  \n  if (!resource) {\n    return { error: 'Not found' }\n  }\n  \n  if (!permissions.canEdit) {\n    return { error: 'Forbidden' }\n  }\n  \n  return await updateResourceData(resource, permissions)\n}\n\n// Correct: fetches only when needed\nasync function updateResource(resourceId: string, userId: string) {\n  const resource = await getResource(resourceId)\n  \n  if (!resource) {\n    return { error: 'Not found' }\n  }\n  \n  const permissions = await fetchPermissions(userId)\n  \n  if (!permissions.canEdit) {\n    return { error: 'Forbidden' }\n  }\n  \n  return await updateResourceData(resource, permissions)\n}\n```\n\nThis optimization is especially valuable when the skipped branch is frequently taken, or when the deferred operation is expensive.",
        "---\ntitle: Dependency-Based Parallelization\nimpact: CRITICAL\nimpactDescription: 2-10\u00d7 improvement\ntags: async, parallelization, dependencies, better-all\n---\n\n## Dependency-Based Parallelization\n\nFor operations with partial dependencies, use `better-all` to maximize parallelism. It automatically starts each task at the earliest possible moment.\n\n**Incorrect (profile waits for config unnecessarily):**\n\n```typescript\nconst [user, config] = await Promise.all([\n  fetchUser(),\n  fetchConfig()\n])\nconst profile = await fetchProfile(user.id)\n```\n\n**Correct (config and profile run in parallel):**\n\n```typescript\nimport { all } from 'better-all'\n\nconst { user, config, profile } = await all({\n  async user() { return fetchUser() },\n  async config() { return fetchConfig() },\n  async profile() {\n    return fetchProfile((await this.$.user).id)\n  }\n})\n```\n\n**Alternative without extra dependencies:**\n\nWe can also create all the promises first, and do `Promise.all()` at the end.\n\n```typescript\nconst userPromise = fetchUser()\nconst profilePromise = userPromise.then(user => fetchProfile(user.id))\n\nconst [user, config, profile] = await Promise.all([\n  userPromise,\n  fetchConfig(),\n  profilePromise\n])\n```\n\nReference: [https://github.com/shuding/better-all](https://github.com/shuding/better-all)",
        "---\ntitle: Promise.all() for Independent Operations\nimpact: CRITICAL\nimpactDescription: 2-10\u00d7 improvement\ntags: async, parallelization, promises, waterfalls\n---\n\n## Promise.all() for Independent Operations\n\nWhen async operations have no interdependencies, execute them concurrently using `Promise.all()`.\n\n**Incorrect (sequential execution, 3 round trips):**\n\n```typescript\nconst user = await fetchUser()\nconst posts = await fetchPosts()\nconst comments = await fetchComments()\n```\n\n**Correct (parallel execution, 1 round trip):**\n\n```typescript\nconst [user, posts, comments] = await Promise.all([\n  fetchUser(),\n  fetchPosts(),\n  fetchComments()\n])\n```",
        "---\ntitle: Strategic Suspense Boundaries\nimpact: HIGH\nimpactDescription: faster initial paint\ntags: async, suspense, streaming, layout-shift\n---\n\n## Strategic Suspense Boundaries\n\nInstead of awaiting data in async components before returning JSX, use Suspense boundaries to show the wrapper UI faster while data loads.\n\n**Incorrect (wrapper blocked by data fetching):**\n\n```tsx\nasync function Page() {\n  const data = await fetchData() // Blocks entire page\n  \n  return (\n    <div>\n      <div>Sidebar</div>\n      <div>Header</div>\n      <div>\n        <DataDisplay data={data} />\n      </div>\n      <div>Footer</div>\n    </div>\n  )\n}\n```\n\nThe entire layout waits for data even though only the middle section needs it.\n\n**Correct (wrapper shows immediately, data streams in):**\n\n```tsx\nfunction Page() {\n  return (\n    <div>\n      <div>Sidebar</div>\n      <div>Header</div>\n      <div>\n        <Suspense fallback={<Skeleton />}>\n          <DataDisplay />\n        </Suspense>\n      </div>\n      <div>Footer</div>\n    </div>\n  )\n}\n\nasync function DataDisplay() {\n  const data = await fetchData() // Only blocks this component\n  return <div>{data.content}</div>\n}\n```\n\nSidebar, Header, and Footer render immediately. Only DataDisplay waits for data.\n\n**Alternative (share promise across components):**\n\n```tsx\nfunction Page() {\n  // Start fetch immediately, but don't await\n  const dataPromise = fetchData()\n  \n  return (\n    <div>\n      <div>Sidebar</div>\n      <div>Header</div>\n      <Suspense fallback={<Skeleton />}>\n        <DataDisplay dataPromise={dataPromise} />\n        <DataSummary dataPromise={dataPromise} />\n      </Suspense>\n      <div>Footer</div>\n    </div>\n  )\n}\n\nfunction DataDisplay({ dataPromise }: { dataPromise: Promise<Data> }) {\n  const data = use(dataPromise) // Unwraps the promise\n  return <div>{data.content}</div>\n}\n\nfunction DataSummary({ dataPromise }: { dataPromise: Promise<Data> }) {\n  const data = use(dataPromise) // Reuses the same promise\n  return <div>{data.summary}</div>\n}\n```\n\nBoth components share the same promise, so only one fetch occurs. Layout renders immediately while both components wait together.\n\n**When NOT to use this pattern:**\n\n- Critical data needed for layout decisions (affects positioning)\n- SEO-critical content above the fold\n- Small, fast queries where suspense overhead isn't worth it\n- When you want to avoid layout shift (loading \u2192 content jump)\n\n**Trade-off:** Faster initial paint vs potential layout shift. Choose based on your UX priorities.",
        "---\ntitle: Avoid Barrel File Imports\nimpact: CRITICAL\nimpactDescription: 200-800ms import cost, slow builds\ntags: bundle, imports, tree-shaking, barrel-files, performance\n---\n\n## Avoid Barrel File Imports\n\nImport directly from source files instead of barrel files to avoid loading thousands of unused modules. **Barrel files** are entry points that re-export multiple modules (e.g., `index.js` that does `export * from './module'`).\n\nPopular icon and component libraries can have **up to 10,000 re-exports** in their entry file. For many React packages, **it takes 200-800ms just to import them**, affecting both development speed and production cold starts.\n\n**Why tree-shaking doesn't help:** When a library is marked as external (not bundled), the bundler can't optimize it. If you bundle it to enable tree-shaking, builds become substantially slower analyzing the entire module graph.\n\n**Incorrect (imports entire library):**\n\n```tsx\nimport { Check, X, Menu } from 'lucide-react'\n// Loads 1,583 modules, takes ~2.8s extra in dev\n// Runtime cost: 200-800ms on every cold start\n\nimport { Button, TextField } from '@mui/material'\n// Loads 2,225 modules, takes ~4.2s extra in dev\n```\n\n**Correct (imports only what you need):**\n\n```tsx\nimport Check from 'lucide-react/dist/esm/icons/check'\nimport X from 'lucide-react/dist/esm/icons/x'\nimport Menu from 'lucide-react/dist/esm/icons/menu'\n// Loads only 3 modules (~2KB vs ~1MB)\n\nimport Button from '@mui/material/Button'\nimport TextField from '@mui/material/TextField'\n// Loads only what you use\n```\n\n**Alternative (Next.js 13.5+):**\n\n```js\n// next.config.js - use optimizePackageImports\nmodule.exports = {\n  experimental: {\n    optimizePackageImports: ['lucide-react', '@mui/material']\n  }\n}\n\n// Then you can keep the ergonomic barrel imports:\nimport { Check, X, Menu } from 'lucide-react'\n// Automatically transformed to direct imports at build time\n```\n\nDirect imports provide 15-70% faster dev boot, 28% faster builds, 40% faster cold starts, and significantly faster HMR.\n\nLibraries commonly affected: `lucide-react`, `@mui/material`, `@mui/icons-material`, `@tabler/icons-react`, `react-icons`, `@headlessui/react`, `@radix-ui/react-*`, `lodash`, `ramda`, `date-fns`, `rxjs`, `react-use`.\n\nReference: [How we optimized package imports in Next.js](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js)",
        "---\ntitle: Conditional Module Loading\nimpact: HIGH\nimpactDescription: loads large data only when needed\ntags: bundle, conditional-loading, lazy-loading\n---\n\n## Conditional Module Loading\n\nLoad large data or modules only when a feature is activated.\n\n**Example (lazy-load animation frames):**\n\n```tsx\nfunction AnimationPlayer({ enabled, setEnabled }: { enabled: boolean; setEnabled: React.Dispatch<React.SetStateAction<boolean>> }) {\n  const [frames, setFrames] = useState<Frame[] | null>(null)\n\n  useEffect(() => {\n    if (enabled && !frames && typeof window !== 'undefined') {\n      import('./animation-frames.js')\n        .then(mod => setFrames(mod.frames))\n        .catch(() => setEnabled(false))\n    }\n  }, [enabled, frames, setEnabled])\n\n  if (!frames) return <Skeleton />\n  return <Canvas frames={frames} />\n}\n```\n\nThe `typeof window !== 'undefined'` check prevents bundling this module for SSR, optimizing server bundle size and build speed.",
        "---\ntitle: Defer Non-Critical Third-Party Libraries\nimpact: MEDIUM\nimpactDescription: loads after hydration\ntags: bundle, third-party, analytics, defer\n---\n\n## Defer Non-Critical Third-Party Libraries\n\nAnalytics, logging, and error tracking don't block user interaction. Load them after hydration.\n\n**Incorrect (blocks initial bundle):**\n\n```tsx\nimport { Analytics } from '@vercel/analytics/react'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        {children}\n        <Analytics />\n      </body>\n    </html>\n  )\n}\n```\n\n**Correct (loads after hydration):**\n\n```tsx\nimport dynamic from 'next/dynamic'\n\nconst Analytics = dynamic(\n  () => import('@vercel/analytics/react').then(m => m.Analytics),\n  { ssr: false }\n)\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        {children}\n        <Analytics />\n      </body>\n    </html>\n  )\n}\n```",
        "---\ntitle: Dynamic Imports for Heavy Components\nimpact: CRITICAL\nimpactDescription: directly affects TTI and LCP\ntags: bundle, dynamic-import, code-splitting, next-dynamic\n---\n\n## Dynamic Imports for Heavy Components\n\nUse `next/dynamic` to lazy-load large components not needed on initial render.\n\n**Incorrect (Monaco bundles with main chunk ~300KB):**\n\n```tsx\nimport { MonacoEditor } from './monaco-editor'\n\nfunction CodePanel({ code }: { code: string }) {\n  return <MonacoEditor value={code} />\n}\n```\n\n**Correct (Monaco loads on demand):**\n\n```tsx\nimport dynamic from 'next/dynamic'\n\nconst MonacoEditor = dynamic(\n  () => import('./monaco-editor').then(m => m.MonacoEditor),\n  { ssr: false }\n)\n\nfunction CodePanel({ code }: { code: string }) {\n  return <MonacoEditor value={code} />\n}\n```",
        "---\ntitle: Preload Based on User Intent\nimpact: MEDIUM\nimpactDescription: reduces perceived latency\ntags: bundle, preload, user-intent, hover\n---\n\n## Preload Based on User Intent\n\nPreload heavy bundles before they're needed to reduce perceived latency.\n\n**Example (preload on hover/focus):**\n\n```tsx\nfunction EditorButton({ onClick }: { onClick: () => void }) {\n  const preload = () => {\n    if (typeof window !== 'undefined') {\n      void import('./monaco-editor')\n    }\n  }\n\n  return (\n    <button\n      onMouseEnter={preload}\n      onFocus={preload}\n      onClick={onClick}\n    >\n      Open Editor\n    </button>\n  )\n}\n```\n\n**Example (preload when feature flag is enabled):**\n\n```tsx\nfunction FlagsProvider({ children, flags }: Props) {\n  useEffect(() => {\n    if (flags.editorEnabled && typeof window !== 'undefined') {\n      void import('./monaco-editor').then(mod => mod.init())\n    }\n  }, [flags.editorEnabled])\n\n  return <FlagsContext.Provider value={flags}>\n    {children}\n  </FlagsContext.Provider>\n}\n```\n\nThe `typeof window !== 'undefined'` check prevents bundling preloaded modules for SSR, optimizing server bundle size and build speed.",
        "---\ntitle: Deduplicate Global Event Listeners\nimpact: LOW\nimpactDescription: single listener for N components\ntags: client, swr, event-listeners, subscription\n---\n\n## Deduplicate Global Event Listeners\n\nUse `useSWRSubscription()` to share global event listeners across component instances.\n\n**Incorrect (N instances = N listeners):**\n\n```tsx\nfunction useKeyboardShortcut(key: string, callback: () => void) {\n  useEffect(() => {\n    const handler = (e: KeyboardEvent) => {\n      if (e.metaKey && e.key === key) {\n        callback()\n      }\n    }\n    window.addEventListener('keydown', handler)\n    return () => window.removeEventListener('keydown', handler)\n  }, [key, callback])\n}\n```\n\nWhen using the `useKeyboardShortcut` hook multiple times, each instance will register a new listener.\n\n**Correct (N instances = 1 listener):**\n\n```tsx\nimport useSWRSubscription from 'swr/subscription'\n\n// Module-level Map to track callbacks per key\nconst keyCallbacks = new Map<string, Set<() => void>>()\n\nfunction useKeyboardShortcut(key: string, callback: () => void) {\n  // Register this callback in the Map\n  useEffect(() => {\n    if (!keyCallbacks.has(key)) {\n      keyCallbacks.set(key, new Set())\n    }\n    keyCallbacks.get(key)!.add(callback)\n\n    return () => {\n      const set = keyCallbacks.get(key)\n      if (set) {\n        set.delete(callback)\n        if (set.size === 0) {\n          keyCallbacks.delete(key)\n        }\n      }\n    }\n  }, [key, callback])\n\n  useSWRSubscription('global-keydown', () => {\n    const handler = (e: KeyboardEvent) => {\n      if (e.metaKey && keyCallbacks.has(e.key)) {\n        keyCallbacks.get(e.key)!.forEach(cb => cb())\n      }\n    }\n    window.addEventListener('keydown', handler)\n    return () => window.removeEventListener('keydown', handler)\n  })\n}\n\nfunction Profile() {\n  // Multiple shortcuts will share the same listener\n  useKeyboardShortcut('p', () => { /* ... */ }) \n  useKeyboardShortcut('k', () => { /* ... */ })\n  // ...\n}\n```",
        "---\ntitle: Version and Minimize localStorage Data\nimpact: MEDIUM\nimpactDescription: prevents schema conflicts, reduces storage size\ntags: client, localStorage, storage, versioning, data-minimization\n---\n\n## Version and Minimize localStorage Data\n\nAdd version prefix to keys and store only needed fields. Prevents schema conflicts and accidental storage of sensitive data.\n\n**Incorrect:**\n\n```typescript\n// No version, stores everything, no error handling\nlocalStorage.setItem('userConfig', JSON.stringify(fullUserObject))\nconst data = localStorage.getItem('userConfig')\n```\n\n**Correct:**\n\n```typescript\nconst VERSION = 'v2'\n\nfunction saveConfig(config: { theme: string; language: string }) {\n  try {\n    localStorage.setItem(`userConfig:${VERSION}`, JSON.stringify(config))\n  } catch {\n    // Throws in incognito/private browsing, quota exceeded, or disabled\n  }\n}\n\nfunction loadConfig() {\n  try {\n    const data = localStorage.getItem(`userConfig:${VERSION}`)\n    return data ? JSON.parse(data) : null\n  } catch {\n    return null\n  }\n}\n\n// Migration from v1 to v2\nfunction migrate() {\n  try {\n    const v1 = localStorage.getItem('userConfig:v1')\n    if (v1) {\n      const old = JSON.parse(v1)\n      saveConfig({ theme: old.darkMode ? 'dark' : 'light', language: old.lang })\n      localStorage.removeItem('userConfig:v1')\n    }\n  } catch {}\n}\n```\n\n**Store minimal fields from server responses:**\n\n```typescript\n// User object has 20+ fields, only store what UI needs\nfunction cachePrefs(user: FullUser) {\n  try {\n    localStorage.setItem('prefs:v1', JSON.stringify({\n      theme: user.preferences.theme,\n      notifications: user.preferences.notifications\n    }))\n  } catch {}\n}\n```\n\n**Always wrap in try-catch:** `getItem()` and `setItem()` throw in incognito/private browsing (Safari, Firefox), when quota exceeded, or when disabled.\n\n**Benefits:** Schema evolution via versioning, reduced storage size, prevents storing tokens/PII/internal flags.",
        "---\ntitle: Use Passive Event Listeners for Scrolling Performance\nimpact: MEDIUM\nimpactDescription: eliminates scroll delay caused by event listeners\ntags: client, event-listeners, scrolling, performance, touch, wheel\n---\n\n## Use Passive Event Listeners for Scrolling Performance\n\nAdd `{ passive: true }` to touch and wheel event listeners to enable immediate scrolling. Browsers normally wait for listeners to finish to check if `preventDefault()` is called, causing scroll delay.\n\n**Incorrect:**\n\n```typescript\nuseEffect(() => {\n  const handleTouch = (e: TouchEvent) => console.log(e.touches[0].clientX)\n  const handleWheel = (e: WheelEvent) => console.log(e.deltaY)\n  \n  document.addEventListener('touchstart', handleTouch)\n  document.addEventListener('wheel', handleWheel)\n  \n  return () => {\n    document.removeEventListener('touchstart', handleTouch)\n    document.removeEventListener('wheel', handleWheel)\n  }\n}, [])\n```\n\n**Correct:**\n\n```typescript\nuseEffect(() => {\n  const handleTouch = (e: TouchEvent) => console.log(e.touches[0].clientX)\n  const handleWheel = (e: WheelEvent) => console.log(e.deltaY)\n  \n  document.addEventListener('touchstart', handleTouch, { passive: true })\n  document.addEventListener('wheel', handleWheel, { passive: true })\n  \n  return () => {\n    document.removeEventListener('touchstart', handleTouch)\n    document.removeEventListener('wheel', handleWheel)\n  }\n}, [])\n```\n\n**Use passive when:** tracking/analytics, logging, any listener that doesn't call `preventDefault()`.\n\n**Don't use passive when:** implementing custom swipe gestures, custom zoom controls, or any listener that needs `preventDefault()`.",
        "---\ntitle: Use SWR for Automatic Deduplication\nimpact: MEDIUM-HIGH\nimpactDescription: automatic deduplication\ntags: client, swr, deduplication, data-fetching\n---\n\n## Use SWR for Automatic Deduplication\n\nSWR enables request deduplication, caching, and revalidation across component instances.\n\n**Incorrect (no deduplication, each instance fetches):**\n\n```tsx\nfunction UserList() {\n  const [users, setUsers] = useState([])\n  useEffect(() => {\n    fetch('/api/users')\n      .then(r => r.json())\n      .then(setUsers)\n  }, [])\n}\n```\n\n**Correct (multiple instances share one request):**\n\n```tsx\nimport useSWR from 'swr'\n\nfunction UserList() {\n  const { data: users } = useSWR('/api/users', fetcher)\n}\n```\n\n**For immutable data:**\n\n```tsx\nimport { useImmutableSWR } from '@/lib/swr'\n\nfunction StaticContent() {\n  const { data } = useImmutableSWR('/api/config', fetcher)\n}\n```\n\n**For mutations:**\n\n```tsx\nimport { useSWRMutation } from 'swr/mutation'\n\nfunction UpdateButton() {\n  const { trigger } = useSWRMutation('/api/user', updateUser)\n  return <button onClick={() => trigger()}>Update</button>\n}\n```\n\nReference: [https://swr.vercel.app](https://swr.vercel.app)",
        "# Development Workflow\n\n## Use Dev Servers Instead of Repeated Builds\n\nWhen developing and testing changes, prefer running a dev server over repeatedly building:\n\n### Starting Development\n\n```bash\n# Start the dev server in background\nBackgroundBash(\"npm run dev\", \"frontend-dev\")\n\n# Check if it started successfully\nReadLogs(\"frontend-dev\")\n```\n\n### Checking for Errors\n\nAfter making changes, check the dev server logs for compilation errors:\n\n```bash\nReadLogs(\"frontend-dev\", 50)  # Last 50 lines\n```\n\nLook for:\n\n- `Failed to compile` - Build errors\n- `Module not found` - Missing imports\n- `error` - General errors\n- `Compiled successfully` or `ready` - Changes worked\n\n### When to Use Build vs Dev Server\n\n| Task                  | Use                                            |\n| --------------------- | ---------------------------------------------- |\n| Initial setup         | `Bash(\"npm install\")`                          |\n| Development iteration | `BackgroundBash(\"npm run dev\")` + `ReadLogs()` |\n| Final verification    | `Bash(\"npm run build\")`                        |\n| Running tests         | `Bash(\"npm test\")`                             |\n\n### Managing Background Processes\n\n```bash\nListProcesses()             # See all running processes\nStopProcess(\"frontend-dev\") # Stop a process\n```",
        "# Efficient File Editing\n\n## Batch Your Edits\n\nWhen fixing multiple issues in the same file, **combine them into a single edit operation** instead of making multiple sequential edits.\n\n### \u274c Inefficient (Multiple Edits)\n\n```\n1. Edit file to fix import\n2. Edit file to fix type annotation\n3. Edit file to fix unused variable\n4. Edit file to add missing parameter\n```\n\n### \u2705 Efficient (Single Batched Edit)\n\n```\n1. Edit file to:\n   - Fix import\n   - Fix type annotation\n   - Fix unused variable\n   - Add missing parameter\n```\n\n## When to Batch\n\n- **TypeScript/compilation errors**: Fix all errors in a file in one edit\n- **Linting issues**: Address all lint warnings in one edit\n- **Related changes**: If changes are in the same file and related, batch them\n\n## When NOT to Batch\n\n- **Different files**: Each file needs its own edit\n- **Unrelated changes**: If fixing a bug AND adding a feature, do them separately\n- **Testing between changes**: If you need to test after each change\n\n## Example\n\nIf you see 5 TypeScript errors in `portfolio-chart.tsx`:\n\n1. Read the file once\n2. Identify ALL the issues\n3. Make ONE edit that fixes all 5 errors\n4. Then run the type check\n\nThis saves tool calls and is more efficient.",
        "# React Folder Structure & Organization\n\nThis document defines the mandatory folder structure for React applications, ensuring consistency with the project's architectural patterns (mirroring the NestJS backend structure where applicable).\n\n## 1. Top-Level Structure\n\nThe `src` directory MUST contain at least these two primary directories:\n\n- `src/common/`: For shared code, components, and logic used across multiple pages or features.\n- `src/pages/`: For page-specific logic and code.\n\n## 2. Page Structure\n\nEach page in the application MUST have its own directory within `src/pages/`.\nThe page directory MUST follow this structure:\n\n```\nsrc/pages/<PageName>/\n\u251c\u2500\u2500 components/        # Components specific to this page\n\u251c\u2500\u2500 hooks/             # Custom hooks used only on this page\n\u251c\u2500\u2500 utils/             # Utility functions for this page\n\u251c\u2500\u2500 enums/             # Enums specific to this page\n\u251c\u2500\u2500 dtos/              # Data Transfer Objects (types/interfaces)\n\u251c\u2500\u2500 dms/               # Domain Models (logic-less data structures)\n\u251c\u2500\u2500 vms/               # View Models (state logic for complex views)\n\u251c\u2500\u2500 <PageName>.tsx     # The main page component\n\u2514\u2500\u2500 index.ts           # Public API export (optional)\n```\n\n**Note**: Not all subfolders are required if the page is simple, but if these elements exist, they MUST be placed in these folders.\n\n## 3. Component Structure\n\nComponents that are complex or have specific dependencies MUST be contained in their own directory.\nThe component directory MUST follow this structure:\n\n```\nsrc/.../components/<ComponentName>/\n\u251c\u2500\u2500 <ComponentName>.tsx        # The component implementation\n\u251c\u2500\u2500 <ComponentName>.styles.ts  # (Or .css/.scss modules)\n\u251c\u2500\u2500 hooks/                     # Hooks specific to this component\n\u251c\u2500\u2500 utils/                     # Utils specific to this component\n\u251c\u2500\u2500 enums/                     # Enums specific to this component\n\u251c\u2500\u2500 dtos/                      # DTOs specific to this component\n\u251c\u2500\u2500 dms/                       # Domain Models\n\u2514\u2500\u2500 vms/                       # View Models\n```\n\n**Rule**: If a component has **any** helper files (hooks, utils, types), it MUST be in its own directory. Only simple, single-file components may reside directly in a `components/` folder without a dedicated sub-directory.\n\n## 4. Common Structure\n\nThe `src/common` directory follows a similar pattern for shared resources:\n\n```\nsrc/common/\n\u251c\u2500\u2500 components/        # Shared UI components (Buttons, Inputs, etc.)\n\u251c\u2500\u2500 hooks/             # Shared hooks (useAuth, useTheme, etc.)\n\u251c\u2500\u2500 utils/             # Shared utilities (formatting, validation, etc.)\n\u251c\u2500\u2500 enums/             # Global enums\n\u251c\u2500\u2500 dtos/              # Shared DTOs\n\u251c\u2500\u2500 dms/               # Shared Domain Models\n\u2514\u2500\u2500 vms/               # Shared View Models\n```\n\n## 5. Key Definitions\n\n- **DTO (Data Transfer Object)**: Interfaces defining data shapes matching API responses or requests.\n- **DM (Domain Model)**: Internal data structures used within the application logic, transformed from DTOs.\n- **VM (View Model)**: Classes or custom hooks that encapsulate complex state logic and view-specific data transformations, keeping the UI component clean.",
        "---\ntitle: Avoid Layout Thrashing\nimpact: MEDIUM\nimpactDescription: prevents forced synchronous layouts and reduces performance bottlenecks\ntags: javascript, dom, css, performance, reflow, layout-thrashing\n---\n\n## Avoid Layout Thrashing\n\nAvoid interleaving style writes with layout reads. When you read a layout property (like `offsetWidth`, `getBoundingClientRect()`, or `getComputedStyle()`) between style changes, the browser is forced to trigger a synchronous reflow.\n\n**This is OK (browser batches style changes):**\n```typescript\nfunction updateElementStyles(element: HTMLElement) {\n  // Each line invalidates style, but browser batches the recalculation\n  element.style.width = '100px'\n  element.style.height = '200px'\n  element.style.backgroundColor = 'blue'\n  element.style.border = '1px solid black'\n}\n```\n\n**Incorrect (interleaved reads and writes force reflows):**\n```typescript\nfunction layoutThrashing(element: HTMLElement) {\n  element.style.width = '100px'\n  const width = element.offsetWidth  // Forces reflow\n  element.style.height = '200px'\n  const height = element.offsetHeight  // Forces another reflow\n}\n```\n\n**Correct (batch writes, then read once):**\n```typescript\nfunction updateElementStyles(element: HTMLElement) {\n  // Batch all writes together\n  element.style.width = '100px'\n  element.style.height = '200px'\n  element.style.backgroundColor = 'blue'\n  element.style.border = '1px solid black'\n  \n  // Read after all writes are done (single reflow)\n  const { width, height } = element.getBoundingClientRect()\n}\n```\n\n**Correct (batch reads, then writes):**\n```typescript\nfunction avoidThrashing(element: HTMLElement) {\n  // Read phase - all layout queries first\n  const rect1 = element.getBoundingClientRect()\n  const offsetWidth = element.offsetWidth\n  const offsetHeight = element.offsetHeight\n  \n  // Write phase - all style changes after\n  element.style.width = '100px'\n  element.style.height = '200px'\n}\n```\n\n**Better: use CSS classes**\n```css\n.highlighted-box {\n  width: 100px;\n  height: 200px;\n  background-color: blue;\n  border: 1px solid black;\n}\n```\n```typescript\nfunction updateElementStyles(element: HTMLElement) {\n  element.classList.add('highlighted-box')\n  \n  const { width, height } = element.getBoundingClientRect()\n}\n```\n\n**React example:**\n```tsx\n// Incorrect: interleaving style changes with layout queries\nfunction Box({ isHighlighted }: { isHighlighted: boolean }) {\n  const ref = useRef<HTMLDivElement>(null)\n  \n  useEffect(() => {\n    if (ref.current && isHighlighted) {\n      ref.current.style.width = '100px'\n      const width = ref.current.offsetWidth // Forces layout\n      ref.current.style.height = '200px'\n    }\n  }, [isHighlighted])\n  \n  return <div ref={ref}>Content</div>\n}\n\n// Correct: toggle class\nfunction Box({ isHighlighted }: { isHighlighted: boolean }) {\n  return (\n    <div className={isHighlighted ? 'highlighted-box' : ''}>\n      Content\n    </div>\n  )\n}\n```\n\nPrefer CSS classes over inline styles when possible. CSS files are cached by the browser, and classes provide better separation of concerns and are easier to maintain.\n\nSee [this gist](https://gist.github.com/paulirish/5d52fb081b3570c81e3a) and [CSS Triggers](https://csstriggers.com/) for more information on layout-forcing operations.",
        "---\ntitle: Cache Repeated Function Calls\nimpact: MEDIUM\nimpactDescription: avoid redundant computation\ntags: javascript, cache, memoization, performance\n---\n\n## Cache Repeated Function Calls\n\nUse a module-level Map to cache function results when the same function is called repeatedly with the same inputs during render.\n\n**Incorrect (redundant computation):**\n\n```typescript\nfunction ProjectList({ projects }: { projects: Project[] }) {\n  return (\n    <div>\n      {projects.map(project => {\n        // slugify() called 100+ times for same project names\n        const slug = slugify(project.name)\n        \n        return <ProjectCard key={project.id} slug={slug} />\n      })}\n    </div>\n  )\n}\n```\n\n**Correct (cached results):**\n\n```typescript\n// Module-level cache\nconst slugifyCache = new Map<string, string>()\n\nfunction cachedSlugify(text: string): string {\n  if (slugifyCache.has(text)) {\n    return slugifyCache.get(text)!\n  }\n  const result = slugify(text)\n  slugifyCache.set(text, result)\n  return result\n}\n\nfunction ProjectList({ projects }: { projects: Project[] }) {\n  return (\n    <div>\n      {projects.map(project => {\n        // Computed only once per unique project name\n        const slug = cachedSlugify(project.name)\n        \n        return <ProjectCard key={project.id} slug={slug} />\n      })}\n    </div>\n  )\n}\n```\n\n**Simpler pattern for single-value functions:**\n\n```typescript\nlet isLoggedInCache: boolean | null = null\n\nfunction isLoggedIn(): boolean {\n  if (isLoggedInCache !== null) {\n    return isLoggedInCache\n  }\n  \n  isLoggedInCache = document.cookie.includes('auth=')\n  return isLoggedInCache\n}\n\n// Clear cache when auth changes\nfunction onAuthChange() {\n  isLoggedInCache = null\n}\n```\n\nUse a Map (not a hook) so it works everywhere: utilities, event handlers, not just React components.\n\nReference: [How we made the Vercel Dashboard twice as fast](https://vercel.com/blog/how-we-made-the-vercel-dashboard-twice-as-fast)",
        "---\ntitle: Cache Property Access in Loops\nimpact: LOW-MEDIUM\nimpactDescription: reduces lookups\ntags: javascript, loops, optimization, caching\n---\n\n## Cache Property Access in Loops\n\nCache object property lookups in hot paths.\n\n**Incorrect (3 lookups \u00d7 N iterations):**\n\n```typescript\nfor (let i = 0; i < arr.length; i++) {\n  process(obj.config.settings.value)\n}\n```\n\n**Correct (1 lookup total):**\n\n```typescript\nconst value = obj.config.settings.value\nconst len = arr.length\nfor (let i = 0; i < len; i++) {\n  process(value)\n}\n```",
        "---\ntitle: Cache Storage API Calls\nimpact: LOW-MEDIUM\nimpactDescription: reduces expensive I/O\ntags: javascript, localStorage, storage, caching, performance\n---\n\n## Cache Storage API Calls\n\n`localStorage`, `sessionStorage`, and `document.cookie` are synchronous and expensive. Cache reads in memory.\n\n**Incorrect (reads storage on every call):**\n\n```typescript\nfunction getTheme() {\n  return localStorage.getItem('theme') ?? 'light'\n}\n// Called 10 times = 10 storage reads\n```\n\n**Correct (Map cache):**\n\n```typescript\nconst storageCache = new Map<string, string | null>()\n\nfunction getLocalStorage(key: string) {\n  if (!storageCache.has(key)) {\n    storageCache.set(key, localStorage.getItem(key))\n  }\n  return storageCache.get(key)\n}\n\nfunction setLocalStorage(key: string, value: string) {\n  localStorage.setItem(key, value)\n  storageCache.set(key, value)  // keep cache in sync\n}\n```\n\nUse a Map (not a hook) so it works everywhere: utilities, event handlers, not just React components.\n\n**Cookie caching:**\n\n```typescript\nlet cookieCache: Record<string, string> | null = null\n\nfunction getCookie(name: string) {\n  if (!cookieCache) {\n    cookieCache = Object.fromEntries(\n      document.cookie.split('; ').map(c => c.split('='))\n    )\n  }\n  return cookieCache[name]\n}\n```\n\n**Important (invalidate on external changes):**\n\nIf storage can change externally (another tab, server-set cookies), invalidate cache:\n\n```typescript\nwindow.addEventListener('storage', (e) => {\n  if (e.key) storageCache.delete(e.key)\n})\n\ndocument.addEventListener('visibilitychange', () => {\n  if (document.visibilityState === 'visible') {\n    storageCache.clear()\n  }\n})\n```",
        "---\ntitle: Combine Multiple Array Iterations\nimpact: LOW-MEDIUM\nimpactDescription: reduces iterations\ntags: javascript, arrays, loops, performance\n---\n\n## Combine Multiple Array Iterations\n\nMultiple `.filter()` or `.map()` calls iterate the array multiple times. Combine into one loop.\n\n**Incorrect (3 iterations):**\n\n```typescript\nconst admins = users.filter(u => u.isAdmin)\nconst testers = users.filter(u => u.isTester)\nconst inactive = users.filter(u => !u.isActive)\n```\n\n**Correct (1 iteration):**\n\n```typescript\nconst admins: User[] = []\nconst testers: User[] = []\nconst inactive: User[] = []\n\nfor (const user of users) {\n  if (user.isAdmin) admins.push(user)\n  if (user.isTester) testers.push(user)\n  if (!user.isActive) inactive.push(user)\n}\n```",
        "---\ntitle: Early Return from Functions\nimpact: LOW-MEDIUM\nimpactDescription: avoids unnecessary computation\ntags: javascript, functions, optimization, early-return\n---\n\n## Early Return from Functions\n\nReturn early when result is determined to skip unnecessary processing.\n\n**Incorrect (processes all items even after finding answer):**\n\n```typescript\nfunction validateUsers(users: User[]) {\n  let hasError = false\n  let errorMessage = ''\n  \n  for (const user of users) {\n    if (!user.email) {\n      hasError = true\n      errorMessage = 'Email required'\n    }\n    if (!user.name) {\n      hasError = true\n      errorMessage = 'Name required'\n    }\n    // Continues checking all users even after error found\n  }\n  \n  return hasError ? { valid: false, error: errorMessage } : { valid: true }\n}\n```\n\n**Correct (returns immediately on first error):**\n\n```typescript\nfunction validateUsers(users: User[]) {\n  for (const user of users) {\n    if (!user.email) {\n      return { valid: false, error: 'Email required' }\n    }\n    if (!user.name) {\n      return { valid: false, error: 'Name required' }\n    }\n  }\n\n  return { valid: true }\n}\n```",
        "---\ntitle: Hoist RegExp Creation\nimpact: LOW-MEDIUM\nimpactDescription: avoids recreation\ntags: javascript, regexp, optimization, memoization\n---\n\n## Hoist RegExp Creation\n\nDon't create RegExp inside render. Hoist to module scope or memoize with `useMemo()`.\n\n**Incorrect (new RegExp every render):**\n\n```tsx\nfunction Highlighter({ text, query }: Props) {\n  const regex = new RegExp(`(${query})`, 'gi')\n  const parts = text.split(regex)\n  return <>{parts.map((part, i) => ...)}</>\n}\n```\n\n**Correct (memoize or hoist):**\n\n```tsx\nconst EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n\nfunction Highlighter({ text, query }: Props) {\n  const regex = useMemo(\n    () => new RegExp(`(${escapeRegex(query)})`, 'gi'),\n    [query]\n  )\n  const parts = text.split(regex)\n  return <>{parts.map((part, i) => ...)}</>\n}\n```\n\n**Warning (global regex has mutable state):**\n\nGlobal regex (`/g`) has mutable `lastIndex` state:\n\n```typescript\nconst regex = /foo/g\nregex.test('foo')  // true, lastIndex = 3\nregex.test('foo')  // false, lastIndex = 0\n```",
        "---\ntitle: Build Index Maps for Repeated Lookups\nimpact: LOW-MEDIUM\nimpactDescription: 1M ops to 2K ops\ntags: javascript, map, indexing, optimization, performance\n---\n\n## Build Index Maps for Repeated Lookups\n\nMultiple `.find()` calls by the same key should use a Map.\n\n**Incorrect (O(n) per lookup):**\n\n```typescript\nfunction processOrders(orders: Order[], users: User[]) {\n  return orders.map(order => ({\n    ...order,\n    user: users.find(u => u.id === order.userId)\n  }))\n}\n```\n\n**Correct (O(1) per lookup):**\n\n```typescript\nfunction processOrders(orders: Order[], users: User[]) {\n  const userById = new Map(users.map(u => [u.id, u]))\n\n  return orders.map(order => ({\n    ...order,\n    user: userById.get(order.userId)\n  }))\n}\n```\n\nBuild map once (O(n)), then all lookups are O(1).\nFor 1000 orders \u00d7 1000 users: 1M ops \u2192 2K ops.",
        "---\ntitle: Early Length Check for Array Comparisons\nimpact: MEDIUM-HIGH\nimpactDescription: avoids expensive operations when lengths differ\ntags: javascript, arrays, performance, optimization, comparison\n---\n\n## Early Length Check for Array Comparisons\n\nWhen comparing arrays with expensive operations (sorting, deep equality, serialization), check lengths first. If lengths differ, the arrays cannot be equal.\n\nIn real-world applications, this optimization is especially valuable when the comparison runs in hot paths (event handlers, render loops).\n\n**Incorrect (always runs expensive comparison):**\n\n```typescript\nfunction hasChanges(current: string[], original: string[]) {\n  // Always sorts and joins, even when lengths differ\n  return current.sort().join() !== original.sort().join()\n}\n```\n\nTwo O(n log n) sorts run even when `current.length` is 5 and `original.length` is 100. There is also overhead of joining the arrays and comparing the strings.\n\n**Correct (O(1) length check first):**\n\n```typescript\nfunction hasChanges(current: string[], original: string[]) {\n  // Early return if lengths differ\n  if (current.length !== original.length) {\n    return true\n  }\n  // Only sort when lengths match\n  const currentSorted = current.toSorted()\n  const originalSorted = original.toSorted()\n  for (let i = 0; i < currentSorted.length; i++) {\n    if (currentSorted[i] !== originalSorted[i]) {\n      return true\n    }\n  }\n  return false\n}\n```\n\nThis new approach is more efficient because:\n- It avoids the overhead of sorting and joining the arrays when lengths differ\n- It avoids consuming memory for the joined strings (especially important for large arrays)\n- It avoids mutating the original arrays\n- It returns early when a difference is found",
        "---\ntitle: Use Loop for Min/Max Instead of Sort\nimpact: LOW\nimpactDescription: O(n) instead of O(n log n)\ntags: javascript, arrays, performance, sorting, algorithms\n---\n\n## Use Loop for Min/Max Instead of Sort\n\nFinding the smallest or largest element only requires a single pass through the array. Sorting is wasteful and slower.\n\n**Incorrect (O(n log n) - sort to find latest):**\n\n```typescript\ninterface Project {\n  id: string\n  name: string\n  updatedAt: number\n}\n\nfunction getLatestProject(projects: Project[]) {\n  const sorted = [...projects].sort((a, b) => b.updatedAt - a.updatedAt)\n  return sorted[0]\n}\n```\n\nSorts the entire array just to find the maximum value.\n\n**Incorrect (O(n log n) - sort for oldest and newest):**\n\n```typescript\nfunction getOldestAndNewest(projects: Project[]) {\n  const sorted = [...projects].sort((a, b) => a.updatedAt - b.updatedAt)\n  return { oldest: sorted[0], newest: sorted[sorted.length - 1] }\n}\n```\n\nStill sorts unnecessarily when only min/max are needed.\n\n**Correct (O(n) - single loop):**\n\n```typescript\nfunction getLatestProject(projects: Project[]) {\n  if (projects.length === 0) return null\n  \n  let latest = projects[0]\n  \n  for (let i = 1; i < projects.length; i++) {\n    if (projects[i].updatedAt > latest.updatedAt) {\n      latest = projects[i]\n    }\n  }\n  \n  return latest\n}\n\nfunction getOldestAndNewest(projects: Project[]) {\n  if (projects.length === 0) return { oldest: null, newest: null }\n  \n  let oldest = projects[0]\n  let newest = projects[0]\n  \n  for (let i = 1; i < projects.length; i++) {\n    if (projects[i].updatedAt < oldest.updatedAt) oldest = projects[i]\n    if (projects[i].updatedAt > newest.updatedAt) newest = projects[i]\n  }\n  \n  return { oldest, newest }\n}\n```\n\nSingle pass through the array, no copying, no sorting.\n\n**Alternative (Math.min/Math.max for small arrays):**\n\n```typescript\nconst numbers = [5, 2, 8, 1, 9]\nconst min = Math.min(...numbers)\nconst max = Math.max(...numbers)\n```\n\nThis works for small arrays, but can be slower or just throw an error for very large arrays due to spread operator limitations. Maximal array length is approximately 124000 in Chrome 143 and 638000 in Safari 18; exact numbers may vary - see [the fiddle](https://jsfiddle.net/qw1jabsx/4/). Use the loop approach for reliability.",
        "---\ntitle: Use Set/Map for O(1) Lookups\nimpact: LOW-MEDIUM\nimpactDescription: O(n) to O(1)\ntags: javascript, set, map, data-structures, performance\n---\n\n## Use Set/Map for O(1) Lookups\n\nConvert arrays to Set/Map for repeated membership checks.\n\n**Incorrect (O(n) per check):**\n\n```typescript\nconst allowedIds = ['a', 'b', 'c', ...]\nitems.filter(item => allowedIds.includes(item.id))\n```\n\n**Correct (O(1) per check):**\n\n```typescript\nconst allowedIds = new Set(['a', 'b', 'c', ...])\nitems.filter(item => allowedIds.has(item.id))\n```",
        "---\ntitle: Use toSorted() Instead of sort() for Immutability\nimpact: MEDIUM-HIGH\nimpactDescription: prevents mutation bugs in React state\ntags: javascript, arrays, immutability, react, state, mutation\n---\n\n## Use toSorted() Instead of sort() for Immutability\n\n`.sort()` mutates the array in place, which can cause bugs with React state and props. Use `.toSorted()` to create a new sorted array without mutation.\n\n**Incorrect (mutates original array):**\n\n```typescript\nfunction UserList({ users }: { users: User[] }) {\n  // Mutates the users prop array!\n  const sorted = useMemo(\n    () => users.sort((a, b) => a.name.localeCompare(b.name)),\n    [users]\n  )\n  return <div>{sorted.map(renderUser)}</div>\n}\n```\n\n**Correct (creates new array):**\n\n```typescript\nfunction UserList({ users }: { users: User[] }) {\n  // Creates new sorted array, original unchanged\n  const sorted = useMemo(\n    () => users.toSorted((a, b) => a.name.localeCompare(b.name)),\n    [users]\n  )\n  return <div>{sorted.map(renderUser)}</div>\n}\n```\n\n**Why this matters in React:**\n\n1. Props/state mutations break React's immutability model - React expects props and state to be treated as read-only\n2. Causes stale closure bugs - Mutating arrays inside closures (callbacks, effects) can lead to unexpected behavior\n\n**Browser support (fallback for older browsers):**\n\n`.toSorted()` is available in all modern browsers (Chrome 110+, Safari 16+, Firefox 115+, Node.js 20+). For older environments, use spread operator:\n\n```typescript\n// Fallback for older browsers\nconst sorted = [...items].sort((a, b) => a.value - b.value)\n```\n\n**Other immutable array methods:**\n\n- `.toSorted()` - immutable sort\n- `.toReversed()` - immutable reverse\n- `.toSpliced()` - immutable splice\n- `.with()` - immutable element replacement",
        "# Plan Before Implementing\n\n## For Complex Features (3+ Components)\n\nBefore writing any code, follow this process:\n\n### 1. **Understand the Architecture**\n\n- Read related existing components to understand patterns\n- Check the folder structure to see where things belong\n- Look for similar features to use as reference\n\n### 2. **Create a Plan**\n\nList out:\n\n- Components you'll need to create\n- Files you'll need to modify\n- Order of implementation (shared utilities first, then components)\n\n### 3. **Verify Your Plan**\n\n- Does it follow the project structure?\n- Does it match existing patterns?\n- Are you missing any files (types, hooks, styles, etc.)?\n\n### 4. **Implement Incrementally**\n\n- Create/modify files in dependency order\n- Test after each major step\n- Fix errors before moving to the next component\n\n## Example: Adding a New Dashboard Widget\n\n### \u274c Bad Approach\n\n```\n1. Create widget component\n2. Get errors about missing types\n3. Add types\n4. Get errors about missing hook\n5. Create hook\n6. Get errors about missing API call\n7. Add API call\n8. Go back and fix everything\n```\n\n### \u2705 Good Approach\n\n```\n1. Plan: Need types \u2192 API call \u2192 hook \u2192 component \u2192 styles\n2. Create types (no dependencies)\n3. Add API call (depends on types)\n4. Create hook (depends on API call)\n5. Create component (depends on hook + types)\n6. Add styles (independent)\n7. Run build & check for errors\n8. Fix any issues\n```\n\n## When to Skip Planning\n\nFor simple tasks (1-2 files, clear requirements), you can skip formal planning:\n\n- Fixing a typo\n- Adding a single function\n- Updating styles\n- Simple bug fixes\n\n## Benefits\n\n- **Fewer errors** - Dependencies are in place before you need them\n- **Fewer tool calls** - Less back-and-forth fixing missing imports\n- **Better code** - You understand the full picture before implementing\n- **Faster completion** - Less rework and debugging",
        "# React Project Initialization\n\nWhen creating a **new** React application, you MUST follow these steps to ensure a modern, performant starting point.\n\n## 1. Use Vite Generator\n\n**Do NOT** use `create-react-app` (it is deprecated/legacy).\n**Do NOT** manually create files for initial scaffold.\n\nUse **Vite** with the React template.\n\n### CRITICAL: Use the generator to CREATE the directory\n\nThe Vite CLI should CREATE the frontend directory itself. Do NOT create the directory first.\n\n**From the project root (NOT inside frontend/):**\n\n```bash\n# Let Vite create the 'frontend' directory\nnpm create vite@latest frontend -- --template react-ts\n```\n\nThis creates a `frontend/` folder with all React+Vite files properly scaffolded.\n\n### If frontend directory already exists\n\nIf the frontend directory already exists and is empty, remove it first:\n\n```bash\nrmdir frontend  # Only works if empty\nnpm create vite@latest frontend -- --template react-ts\n```\n\n### If frontend directory has files (rare - avoid this situation)\n\n```bash\n# Remove and recreate\nrm -rf frontend\nnpm create vite@latest frontend -- --template react-ts\n```\n\n**NEVER use temp directories and move files** - this causes macOS resource fork issues.\n\n## 2. Enforce Node Version\n\nAfter scaffolding, navigate into the folder and set Node version:\n\n```bash\ncd frontend\necho \"v25\" > .nvmrc\n```\n\n## 3. Post-Generation Steps\n\n```bash\nnpm install\nnpm run build  # Verify the setup works\n```\n\n## 4. Initial Clean Up\n\n- Remove default generic Vite assets if not needed (e.g., `src/assets/react.svg`).\n- Update `index.html` title.\n- Setup the standard folder structure defined in `rules/folder-structure.md` (`src/common`, `src/pages`, etc.).\n\n## 5. Package Version Rules\n\n- **NEVER** specify explicit version numbers in package.json\n- Use `@latest` when installing packages: `npm install some-package@latest`\n- Let npm resolve compatible versions automatically\n\n**DO NOT**:\n- Create the `frontend` directory before running the generator\n- Use temp directories and move files\n- Specify explicit version numbers",
        "---\ntitle: Use Activity Component for Show/Hide\nimpact: MEDIUM\nimpactDescription: preserves state/DOM\ntags: rendering, activity, visibility, state-preservation\n---\n\n## Use Activity Component for Show/Hide\n\nUse React's `<Activity>` to preserve state/DOM for expensive components that frequently toggle visibility.\n\n**Usage:**\n\n```tsx\nimport { Activity } from 'react'\n\nfunction Dropdown({ isOpen }: Props) {\n  return (\n    <Activity mode={isOpen ? 'visible' : 'hidden'}>\n      <ExpensiveMenu />\n    </Activity>\n  )\n}\n```\n\nAvoids expensive re-renders and state loss.",
        "---\ntitle: Animate SVG Wrapper Instead of SVG Element\nimpact: LOW\nimpactDescription: enables hardware acceleration\ntags: rendering, svg, css, animation, performance\n---\n\n## Animate SVG Wrapper Instead of SVG Element\n\nMany browsers don't have hardware acceleration for CSS3 animations on SVG elements. Wrap SVG in a `<div>` and animate the wrapper instead.\n\n**Incorrect (animating SVG directly - no hardware acceleration):**\n\n```tsx\nfunction LoadingSpinner() {\n  return (\n    <svg \n      className=\"animate-spin\"\n      width=\"24\" \n      height=\"24\" \n      viewBox=\"0 0 24 24\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" />\n    </svg>\n  )\n}\n```\n\n**Correct (animating wrapper div - hardware accelerated):**\n\n```tsx\nfunction LoadingSpinner() {\n  return (\n    <div className=\"animate-spin\">\n      <svg \n        width=\"24\" \n        height=\"24\" \n        viewBox=\"0 0 24 24\"\n      >\n        <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" />\n      </svg>\n    </div>\n  )\n}\n```\n\nThis applies to all CSS transforms and transitions (`transform`, `opacity`, `translate`, `scale`, `rotate`). The wrapper div allows browsers to use GPU acceleration for smoother animations.",
        "---\ntitle: Use Explicit Conditional Rendering\nimpact: LOW\nimpactDescription: prevents rendering 0 or NaN\ntags: rendering, conditional, jsx, falsy-values\n---\n\n## Use Explicit Conditional Rendering\n\nUse explicit ternary operators (`? :`) instead of `&&` for conditional rendering when the condition can be `0`, `NaN`, or other falsy values that render.\n\n**Incorrect (renders \"0\" when count is 0):**\n\n```tsx\nfunction Badge({ count }: { count: number }) {\n  return (\n    <div>\n      {count && <span className=\"badge\">{count}</span>}\n    </div>\n  )\n}\n\n// When count = 0, renders: <div>0</div>\n// When count = 5, renders: <div><span class=\"badge\">5</span></div>\n```\n\n**Correct (renders nothing when count is 0):**\n\n```tsx\nfunction Badge({ count }: { count: number }) {\n  return (\n    <div>\n      {count > 0 ? <span className=\"badge\">{count}</span> : null}\n    </div>\n  )\n}\n\n// When count = 0, renders: <div></div>\n// When count = 5, renders: <div><span class=\"badge\">5</span></div>\n```",
        "---\ntitle: CSS content-visibility for Long Lists\nimpact: HIGH\nimpactDescription: faster initial render\ntags: rendering, css, content-visibility, long-lists\n---\n\n## CSS content-visibility for Long Lists\n\nApply `content-visibility: auto` to defer off-screen rendering.\n\n**CSS:**\n\n```css\n.message-item {\n  content-visibility: auto;\n  contain-intrinsic-size: 0 80px;\n}\n```\n\n**Example:**\n\n```tsx\nfunction MessageList({ messages }: { messages: Message[] }) {\n  return (\n    <div className=\"overflow-y-auto h-screen\">\n      {messages.map(msg => (\n        <div key={msg.id} className=\"message-item\">\n          <Avatar user={msg.author} />\n          <div>{msg.content}</div>\n        </div>\n      ))}\n    </div>\n  )\n}\n```\n\nFor 1000 messages, browser skips layout/paint for ~990 off-screen items (10\u00d7 faster initial render).",
        "---\ntitle: Hoist Static JSX Elements\nimpact: LOW\nimpactDescription: avoids re-creation\ntags: rendering, jsx, static, optimization\n---\n\n## Hoist Static JSX Elements\n\nExtract static JSX outside components to avoid re-creation.\n\n**Incorrect (recreates element every render):**\n\n```tsx\nfunction LoadingSkeleton() {\n  return <div className=\"animate-pulse h-20 bg-gray-200\" />\n}\n\nfunction Container() {\n  return (\n    <div>\n      {loading && <LoadingSkeleton />}\n    </div>\n  )\n}\n```\n\n**Correct (reuses same element):**\n\n```tsx\nconst loadingSkeleton = (\n  <div className=\"animate-pulse h-20 bg-gray-200\" />\n)\n\nfunction Container() {\n  return (\n    <div>\n      {loading && loadingSkeleton}\n    </div>\n  )\n}\n```\n\nThis is especially helpful for large and static SVG nodes, which can be expensive to recreate on every render.\n\n**Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, the compiler automatically hoists static JSX elements and optimizes component re-renders, making manual hoisting unnecessary.",
        "---\ntitle: Prevent Hydration Mismatch Without Flickering\nimpact: MEDIUM\nimpactDescription: avoids visual flicker and hydration errors\ntags: rendering, ssr, hydration, localStorage, flicker\n---\n\n## Prevent Hydration Mismatch Without Flickering\n\nWhen rendering content that depends on client-side storage (localStorage, cookies), avoid both SSR breakage and post-hydration flickering by injecting a synchronous script that updates the DOM before React hydrates.\n\n**Incorrect (breaks SSR):**\n\n```tsx\nfunction ThemeWrapper({ children }: { children: ReactNode }) {\n  // localStorage is not available on server - throws error\n  const theme = localStorage.getItem('theme') || 'light'\n  \n  return (\n    <div className={theme}>\n      {children}\n    </div>\n  )\n}\n```\n\nServer-side rendering will fail because `localStorage` is undefined.\n\n**Incorrect (visual flickering):**\n\n```tsx\nfunction ThemeWrapper({ children }: { children: ReactNode }) {\n  const [theme, setTheme] = useState('light')\n  \n  useEffect(() => {\n    // Runs after hydration - causes visible flash\n    const stored = localStorage.getItem('theme')\n    if (stored) {\n      setTheme(stored)\n    }\n  }, [])\n  \n  return (\n    <div className={theme}>\n      {children}\n    </div>\n  )\n}\n```\n\nComponent first renders with default value (`light`), then updates after hydration, causing a visible flash of incorrect content.\n\n**Correct (no flicker, no hydration mismatch):**\n\n```tsx\nfunction ThemeWrapper({ children }: { children: ReactNode }) {\n  return (\n    <>\n      <div id=\"theme-wrapper\">\n        {children}\n      </div>\n      <script\n        dangerouslySetInnerHTML={{\n          __html: `\n            (function() {\n              try {\n                var theme = localStorage.getItem('theme') || 'light';\n                var el = document.getElementById('theme-wrapper');\n                if (el) el.className = theme;\n              } catch (e) {}\n            })();\n          `,\n        }}\n      />\n    </>\n  )\n}\n```\n\nThe inline script executes synchronously before showing the element, ensuring the DOM already has the correct value. No flickering, no hydration mismatch.\n\nThis pattern is especially useful for theme toggles, user preferences, authentication states, and any client-only data that should render immediately without flashing default values.",
        "---\ntitle: Suppress Expected Hydration Mismatches\nimpact: LOW-MEDIUM\nimpactDescription: avoids noisy hydration warnings for known differences\ntags: rendering, hydration, ssr, nextjs\n---\n\n## Suppress Expected Hydration Mismatches\n\nIn SSR frameworks (e.g., Next.js), some values are intentionally different on server vs client (random IDs, dates, locale/timezone formatting). For these *expected* mismatches, wrap the dynamic text in an element with `suppressHydrationWarning` to prevent noisy warnings. Do not use this to hide real bugs. Don\u2019t overuse it.\n\n**Incorrect (known mismatch warnings):**\n\n```tsx\nfunction Timestamp() {\n  return <span>{new Date().toLocaleString()}</span>\n}\n```\n\n**Correct (suppress expected mismatch only):**\n\n```tsx\nfunction Timestamp() {\n  return (\n    <span suppressHydrationWarning>\n      {new Date().toLocaleString()}\n    </span>\n  )\n}\n```",
        "---\ntitle: Optimize SVG Precision\nimpact: LOW\nimpactDescription: reduces file size\ntags: rendering, svg, optimization, svgo\n---\n\n## Optimize SVG Precision\n\nReduce SVG coordinate precision to decrease file size. The optimal precision depends on the viewBox size, but in general reducing precision should be considered.\n\n**Incorrect (excessive precision):**\n\n```svg\n<path d=\"M 10.293847 20.847362 L 30.938472 40.192837\" />\n```\n\n**Correct (1 decimal place):**\n\n```svg\n<path d=\"M 10.3 20.8 L 30.9 40.2\" />\n```\n\n**Automate with SVGO:**\n\n```bash\nnpx svgo --precision=1 --multipass icon.svg\n```",
        "---\ntitle: Use useTransition Over Manual Loading States\nimpact: LOW\nimpactDescription: reduces re-renders and improves code clarity\ntags: rendering, transitions, useTransition, loading, state\n---\n\n## Use useTransition Over Manual Loading States\n\nUse `useTransition` instead of manual `useState` for loading states. This provides built-in `isPending` state and automatically manages transitions.\n\n**Incorrect (manual loading state):**\n\n```tsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('')\n  const [results, setResults] = useState([])\n  const [isLoading, setIsLoading] = useState(false)\n\n  const handleSearch = async (value: string) => {\n    setIsLoading(true)\n    setQuery(value)\n    const data = await fetchResults(value)\n    setResults(data)\n    setIsLoading(false)\n  }\n\n  return (\n    <>\n      <input onChange={(e) => handleSearch(e.target.value)} />\n      {isLoading && <Spinner />}\n      <ResultsList results={results} />\n    </>\n  )\n}\n```\n\n**Correct (useTransition with built-in pending state):**\n\n```tsx\nimport { useTransition, useState } from 'react'\n\nfunction SearchResults() {\n  const [query, setQuery] = useState('')\n  const [results, setResults] = useState([])\n  const [isPending, startTransition] = useTransition()\n\n  const handleSearch = (value: string) => {\n    setQuery(value) // Update input immediately\n    \n    startTransition(async () => {\n      // Fetch and update results\n      const data = await fetchResults(value)\n      setResults(data)\n    })\n  }\n\n  return (\n    <>\n      <input onChange={(e) => handleSearch(e.target.value)} />\n      {isPending && <Spinner />}\n      <ResultsList results={results} />\n    </>\n  )\n}\n```\n\n**Benefits:**\n\n- **Automatic pending state**: No need to manually manage `setIsLoading(true/false)`\n- **Error resilience**: Pending state correctly resets even if the transition throws\n- **Better responsiveness**: Keeps the UI responsive during updates\n- **Interrupt handling**: New transitions automatically cancel pending ones\n\nReference: [useTransition](https://react.dev/reference/react/useTransition)",
        "---\ntitle: Defer State Reads to Usage Point\nimpact: MEDIUM\nimpactDescription: avoids unnecessary subscriptions\ntags: rerender, searchParams, localStorage, optimization\n---\n\n## Defer State Reads to Usage Point\n\nDon't subscribe to dynamic state (searchParams, localStorage) if you only read it inside callbacks.\n\n**Incorrect (subscribes to all searchParams changes):**\n\n```tsx\nfunction ShareButton({ chatId }: { chatId: string }) {\n  const searchParams = useSearchParams()\n\n  const handleShare = () => {\n    const ref = searchParams.get('ref')\n    shareChat(chatId, { ref })\n  }\n\n  return <button onClick={handleShare}>Share</button>\n}\n```\n\n**Correct (reads on demand, no subscription):**\n\n```tsx\nfunction ShareButton({ chatId }: { chatId: string }) {\n  const handleShare = () => {\n    const params = new URLSearchParams(window.location.search)\n    const ref = params.get('ref')\n    shareChat(chatId, { ref })\n  }\n\n  return <button onClick={handleShare}>Share</button>\n}\n```",
        "---\ntitle: Narrow Effect Dependencies\nimpact: LOW\nimpactDescription: minimizes effect re-runs\ntags: rerender, useEffect, dependencies, optimization\n---\n\n## Narrow Effect Dependencies\n\nSpecify primitive dependencies instead of objects to minimize effect re-runs.\n\n**Incorrect (re-runs on any user field change):**\n\n```tsx\nuseEffect(() => {\n  console.log(user.id)\n}, [user])\n```\n\n**Correct (re-runs only when id changes):**\n\n```tsx\nuseEffect(() => {\n  console.log(user.id)\n}, [user.id])\n```\n\n**For derived state, compute outside effect:**\n\n```tsx\n// Incorrect: runs on width=767, 766, 765...\nuseEffect(() => {\n  if (width < 768) {\n    enableMobileMode()\n  }\n}, [width])\n\n// Correct: runs only on boolean transition\nconst isMobile = width < 768\nuseEffect(() => {\n  if (isMobile) {\n    enableMobileMode()\n  }\n}, [isMobile])\n```",
        "---\ntitle: Calculate Derived State During Rendering\nimpact: MEDIUM\nimpactDescription: avoids redundant renders and state drift\ntags: rerender, derived-state, useEffect, state\n---\n\n## Calculate Derived State During Rendering\n\nIf a value can be computed from current props/state, do not store it in state or update it in an effect. Derive it during render to avoid extra renders and state drift. Do not set state in effects solely in response to prop changes; prefer derived values or keyed resets instead.\n\n**Incorrect (redundant state and effect):**\n\n```tsx\nfunction Form() {\n  const [firstName, setFirstName] = useState('First')\n  const [lastName, setLastName] = useState('Last')\n  const [fullName, setFullName] = useState('')\n\n  useEffect(() => {\n    setFullName(firstName + ' ' + lastName)\n  }, [firstName, lastName])\n\n  return <p>{fullName}</p>\n}\n```\n\n**Correct (derive during render):**\n\n```tsx\nfunction Form() {\n  const [firstName, setFirstName] = useState('First')\n  const [lastName, setLastName] = useState('Last')\n  const fullName = firstName + ' ' + lastName\n\n  return <p>{fullName}</p>\n}\n```\n\nReferences: [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)",
        "---\ntitle: Subscribe to Derived State\nimpact: MEDIUM\nimpactDescription: reduces re-render frequency\ntags: rerender, derived-state, media-query, optimization\n---\n\n## Subscribe to Derived State\n\nSubscribe to derived boolean state instead of continuous values to reduce re-render frequency.\n\n**Incorrect (re-renders on every pixel change):**\n\n```tsx\nfunction Sidebar() {\n  const width = useWindowWidth()  // updates continuously\n  const isMobile = width < 768\n  return <nav className={isMobile ? 'mobile' : 'desktop'} />\n}\n```\n\n**Correct (re-renders only when boolean changes):**\n\n```tsx\nfunction Sidebar() {\n  const isMobile = useMediaQuery('(max-width: 767px)')\n  return <nav className={isMobile ? 'mobile' : 'desktop'} />\n}\n```",
        "---\ntitle: Use Functional setState Updates\nimpact: MEDIUM\nimpactDescription: prevents stale closures and unnecessary callback recreations\ntags: react, hooks, useState, useCallback, callbacks, closures\n---\n\n## Use Functional setState Updates\n\nWhen updating state based on the current state value, use the functional update form of setState instead of directly referencing the state variable. This prevents stale closures, eliminates unnecessary dependencies, and creates stable callback references.\n\n**Incorrect (requires state as dependency):**\n\n```tsx\nfunction TodoList() {\n  const [items, setItems] = useState(initialItems)\n  \n  // Callback must depend on items, recreated on every items change\n  const addItems = useCallback((newItems: Item[]) => {\n    setItems([...items, ...newItems])\n  }, [items])  // \u274c items dependency causes recreations\n  \n  // Risk of stale closure if dependency is forgotten\n  const removeItem = useCallback((id: string) => {\n    setItems(items.filter(item => item.id !== id))\n  }, [])  // \u274c Missing items dependency - will use stale items!\n  \n  return <ItemsEditor items={items} onAdd={addItems} onRemove={removeItem} />\n}\n```\n\nThe first callback is recreated every time `items` changes, which can cause child components to re-render unnecessarily. The second callback has a stale closure bug\u2014it will always reference the initial `items` value.\n\n**Correct (stable callbacks, no stale closures):**\n\n```tsx\nfunction TodoList() {\n  const [items, setItems] = useState(initialItems)\n  \n  // Stable callback, never recreated\n  const addItems = useCallback((newItems: Item[]) => {\n    setItems(curr => [...curr, ...newItems])\n  }, [])  // \u2705 No dependencies needed\n  \n  // Always uses latest state, no stale closure risk\n  const removeItem = useCallback((id: string) => {\n    setItems(curr => curr.filter(item => item.id !== id))\n  }, [])  // \u2705 Safe and stable\n  \n  return <ItemsEditor items={items} onAdd={addItems} onRemove={removeItem} />\n}\n```\n\n**Benefits:**\n\n1. **Stable callback references** - Callbacks don't need to be recreated when state changes\n2. **No stale closures** - Always operates on the latest state value\n3. **Fewer dependencies** - Simplifies dependency arrays and reduces memory leaks\n4. **Prevents bugs** - Eliminates the most common source of React closure bugs\n\n**When to use functional updates:**\n\n- Any setState that depends on the current state value\n- Inside useCallback/useMemo when state is needed\n- Event handlers that reference state\n- Async operations that update state\n\n**When direct updates are fine:**\n\n- Setting state to a static value: `setCount(0)`\n- Setting state from props/arguments only: `setName(newName)`\n- State doesn't depend on previous value\n\n**Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, the compiler can automatically optimize some cases, but functional updates are still recommended for correctness and to prevent stale closure bugs.",
        "---\ntitle: Use Lazy State Initialization\nimpact: MEDIUM\nimpactDescription: wasted computation on every render\ntags: react, hooks, useState, performance, initialization\n---\n\n## Use Lazy State Initialization\n\nPass a function to `useState` for expensive initial values. Without the function form, the initializer runs on every render even though the value is only used once.\n\n**Incorrect (runs on every render):**\n\n```tsx\nfunction FilteredList({ items }: { items: Item[] }) {\n  // buildSearchIndex() runs on EVERY render, even after initialization\n  const [searchIndex, setSearchIndex] = useState(buildSearchIndex(items))\n  const [query, setQuery] = useState('')\n  \n  // When query changes, buildSearchIndex runs again unnecessarily\n  return <SearchResults index={searchIndex} query={query} />\n}\n\nfunction UserProfile() {\n  // JSON.parse runs on every render\n  const [settings, setSettings] = useState(\n    JSON.parse(localStorage.getItem('settings') || '{}')\n  )\n  \n  return <SettingsForm settings={settings} onChange={setSettings} />\n}\n```\n\n**Correct (runs only once):**\n\n```tsx\nfunction FilteredList({ items }: { items: Item[] }) {\n  // buildSearchIndex() runs ONLY on initial render\n  const [searchIndex, setSearchIndex] = useState(() => buildSearchIndex(items))\n  const [query, setQuery] = useState('')\n  \n  return <SearchResults index={searchIndex} query={query} />\n}\n\nfunction UserProfile() {\n  // JSON.parse runs only on initial render\n  const [settings, setSettings] = useState(() => {\n    const stored = localStorage.getItem('settings')\n    return stored ? JSON.parse(stored) : {}\n  })\n  \n  return <SettingsForm settings={settings} onChange={setSettings} />\n}\n```\n\nUse lazy initialization when computing initial values from localStorage/sessionStorage, building data structures (indexes, maps), reading from the DOM, or performing heavy transformations.\n\nFor simple primitives (`useState(0)`), direct references (`useState(props.value)`), or cheap literals (`useState({})`), the function form is unnecessary.",
        "---\n\ntitle: Extract Default Non-primitive Parameter Value from Memoized Component to Constant\nimpact: MEDIUM\nimpactDescription: restores memoization by using a constant for default value\ntags: rerender, memo, optimization\n\n---\n\n## Extract Default Non-primitive Parameter Value from Memoized Component to Constant\n\nWhen memoized component has a default value for some non-primitive optional parameter, such as an array, function, or object, calling the component without that parameter results in broken memoization. This is because new value instances are created on every rerender, and they do not pass strict equality comparison in `memo()`.\n\nTo address this issue, extract the default value into a constant.\n\n**Incorrect (`onClick` has different values on every rerender):**\n\n```tsx\nconst UserAvatar = memo(function UserAvatar({ onClick = () => {} }: { onClick?: () => void }) {\n  // ...\n})\n\n// Used without optional onClick\n<UserAvatar />\n```\n\n**Correct (stable default value):**\n\n```tsx\nconst NOOP = () => {};\n\nconst UserAvatar = memo(function UserAvatar({ onClick = NOOP }: { onClick?: () => void }) {\n  // ...\n})\n\n// Used without optional onClick\n<UserAvatar />\n```",
        "---\ntitle: Extract to Memoized Components\nimpact: MEDIUM\nimpactDescription: enables early returns\ntags: rerender, memo, useMemo, optimization\n---\n\n## Extract to Memoized Components\n\nExtract expensive work into memoized components to enable early returns before computation.\n\n**Incorrect (computes avatar even when loading):**\n\n```tsx\nfunction Profile({ user, loading }: Props) {\n  const avatar = useMemo(() => {\n    const id = computeAvatarId(user)\n    return <Avatar id={id} />\n  }, [user])\n\n  if (loading) return <Skeleton />\n  return <div>{avatar}</div>\n}\n```\n\n**Correct (skips computation when loading):**\n\n```tsx\nconst UserAvatar = memo(function UserAvatar({ user }: { user: User }) {\n  const id = useMemo(() => computeAvatarId(user), [user])\n  return <Avatar id={id} />\n})\n\nfunction Profile({ user, loading }: Props) {\n  if (loading) return <Skeleton />\n  return (\n    <div>\n      <UserAvatar user={user} />\n    </div>\n  )\n}\n```\n\n**Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, manual memoization with `memo()` and `useMemo()` is not necessary. The compiler automatically optimizes re-renders.",
        "---\ntitle: Put Interaction Logic in Event Handlers\nimpact: MEDIUM\nimpactDescription: avoids effect re-runs and duplicate side effects\ntags: rerender, useEffect, events, side-effects, dependencies\n---\n\n## Put Interaction Logic in Event Handlers\n\nIf a side effect is triggered by a specific user action (submit, click, drag), run it in that event handler. Do not model the action as state + effect; it makes effects re-run on unrelated changes and can duplicate the action.\n\n**Incorrect (event modeled as state + effect):**\n\n```tsx\nfunction Form() {\n  const [submitted, setSubmitted] = useState(false)\n  const theme = useContext(ThemeContext)\n\n  useEffect(() => {\n    if (submitted) {\n      post('/api/register')\n      showToast('Registered', theme)\n    }\n  }, [submitted, theme])\n\n  return <button onClick={() => setSubmitted(true)}>Submit</button>\n}\n```\n\n**Correct (do it in the handler):**\n\n```tsx\nfunction Form() {\n  const theme = useContext(ThemeContext)\n\n  function handleSubmit() {\n    post('/api/register')\n    showToast('Registered', theme)\n  }\n\n  return <button onClick={handleSubmit}>Submit</button>\n}\n```\n\nReference: [Should this code move to an event handler?](https://react.dev/learn/removing-effect-dependencies#should-this-code-move-to-an-event-handler)",
        "---\ntitle: Do not wrap a simple expression with a primitive result type in useMemo\nimpact: LOW-MEDIUM\nimpactDescription: wasted computation on every render\ntags: rerender, useMemo, optimization\n---\n\n## Do not wrap a simple expression with a primitive result type in useMemo\n\nWhen an expression is simple (few logical or arithmetical operators) and has a primitive result type (boolean, number, string), do not wrap it in `useMemo`.\nCalling `useMemo` and comparing hook dependencies may consume more resources than the expression itself.\n\n**Incorrect:**\n\n```tsx\nfunction Header({ user, notifications }: Props) {\n  const isLoading = useMemo(() => {\n    return user.isLoading || notifications.isLoading\n  }, [user.isLoading, notifications.isLoading])\n\n  if (isLoading) return <Skeleton />\n  // return some markup\n}\n```\n\n**Correct:**\n\n```tsx\nfunction Header({ user, notifications }: Props) {\n  const isLoading = user.isLoading || notifications.isLoading\n\n  if (isLoading) return <Skeleton />\n  // return some markup\n}\n```",
        "---\ntitle: Use Transitions for Non-Urgent Updates\nimpact: MEDIUM\nimpactDescription: maintains UI responsiveness\ntags: rerender, transitions, startTransition, performance\n---\n\n## Use Transitions for Non-Urgent Updates\n\nMark frequent, non-urgent state updates as transitions to maintain UI responsiveness.\n\n**Incorrect (blocks UI on every scroll):**\n\n```tsx\nfunction ScrollTracker() {\n  const [scrollY, setScrollY] = useState(0)\n  useEffect(() => {\n    const handler = () => setScrollY(window.scrollY)\n    window.addEventListener('scroll', handler, { passive: true })\n    return () => window.removeEventListener('scroll', handler)\n  }, [])\n}\n```\n\n**Correct (non-blocking updates):**\n\n```tsx\nimport { startTransition } from 'react'\n\nfunction ScrollTracker() {\n  const [scrollY, setScrollY] = useState(0)\n  useEffect(() => {\n    const handler = () => {\n      startTransition(() => setScrollY(window.scrollY))\n    }\n    window.addEventListener('scroll', handler, { passive: true })\n    return () => window.removeEventListener('scroll', handler)\n  }, [])\n}\n```",
        "---\ntitle: Use useRef for Transient Values\nimpact: MEDIUM\nimpactDescription: avoids unnecessary re-renders on frequent updates\ntags: rerender, useref, state, performance\n---\n\n## Use useRef for Transient Values\n\nWhen a value changes frequently and you don't want a re-render on every update (e.g., mouse trackers, intervals, transient flags), store it in `useRef` instead of `useState`. Keep component state for UI; use refs for temporary DOM-adjacent values. Updating a ref does not trigger a re-render.\n\n**Incorrect (renders every update):**\n\n```tsx\nfunction Tracker() {\n  const [lastX, setLastX] = useState(0)\n\n  useEffect(() => {\n    const onMove = (e: MouseEvent) => setLastX(e.clientX)\n    window.addEventListener('mousemove', onMove)\n    return () => window.removeEventListener('mousemove', onMove)\n  }, [])\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: lastX,\n        width: 8,\n        height: 8,\n        background: 'black',\n      }}\n    />\n  )\n}\n```\n\n**Correct (no re-render for tracking):**\n\n```tsx\nfunction Tracker() {\n  const lastXRef = useRef(0)\n  const dotRef = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    const onMove = (e: MouseEvent) => {\n      lastXRef.current = e.clientX\n      const node = dotRef.current\n      if (node) {\n        node.style.transform = `translateX(${e.clientX}px)`\n      }\n    }\n    window.addEventListener('mousemove', onMove)\n    return () => window.removeEventListener('mousemove', onMove)\n  }, [])\n\n  return (\n    <div\n      ref={dotRef}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: 8,\n        height: 8,\n        background: 'black',\n        transform: 'translateX(0px)',\n      }}\n    />\n  )\n}\n```",
        "---\ntitle: Use after() for Non-Blocking Operations\nimpact: MEDIUM\nimpactDescription: faster response times\ntags: server, async, logging, analytics, side-effects\n---\n\n## Use after() for Non-Blocking Operations\n\nUse Next.js's `after()` to schedule work that should execute after a response is sent. This prevents logging, analytics, and other side effects from blocking the response.\n\n**Incorrect (blocks response):**\n\n```tsx\nimport { logUserAction } from '@/app/utils'\n\nexport async function POST(request: Request) {\n  // Perform mutation\n  await updateDatabase(request)\n  \n  // Logging blocks the response\n  const userAgent = request.headers.get('user-agent') || 'unknown'\n  await logUserAction({ userAgent })\n  \n  return new Response(JSON.stringify({ status: 'success' }), {\n    status: 200,\n    headers: { 'Content-Type': 'application/json' }\n  })\n}\n```\n\n**Correct (non-blocking):**\n\n```tsx\nimport { after } from 'next/server'\nimport { headers, cookies } from 'next/headers'\nimport { logUserAction } from '@/app/utils'\n\nexport async function POST(request: Request) {\n  // Perform mutation\n  await updateDatabase(request)\n  \n  // Log after response is sent\n  after(async () => {\n    const userAgent = (await headers()).get('user-agent') || 'unknown'\n    const sessionCookie = (await cookies()).get('session-id')?.value || 'anonymous'\n    \n    logUserAction({ sessionCookie, userAgent })\n  })\n  \n  return new Response(JSON.stringify({ status: 'success' }), {\n    status: 200,\n    headers: { 'Content-Type': 'application/json' }\n  })\n}\n```\n\nThe response is sent immediately while logging happens in the background.\n\n**Common use cases:**\n\n- Analytics tracking\n- Audit logging\n- Sending notifications\n- Cache invalidation\n- Cleanup tasks\n\n**Important notes:**\n\n- `after()` runs even if the response fails or redirects\n- Works in Server Actions, Route Handlers, and Server Components\n\nReference: [https://nextjs.org/docs/app/api-reference/functions/after](https://nextjs.org/docs/app/api-reference/functions/after)",
        "---\ntitle: Authenticate Server Actions Like API Routes\nimpact: CRITICAL\nimpactDescription: prevents unauthorized access to server mutations\ntags: server, server-actions, authentication, security, authorization\n---\n\n## Authenticate Server Actions Like API Routes\n\n**Impact: CRITICAL (prevents unauthorized access to server mutations)**\n\nServer Actions (functions with `\"use server\"`) are exposed as public endpoints, just like API routes. Always verify authentication and authorization **inside** each Server Action\u2014do not rely solely on middleware, layout guards, or page-level checks, as Server Actions can be invoked directly.\n\nNext.js documentation explicitly states: \"Treat Server Actions with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation.\"\n\n**Incorrect (no authentication check):**\n\n```typescript\n'use server'\n\nexport async function deleteUser(userId: string) {\n  // Anyone can call this! No auth check\n  await db.user.delete({ where: { id: userId } })\n  return { success: true }\n}\n```\n\n**Correct (authentication inside the action):**\n\n```typescript\n'use server'\n\nimport { verifySession } from '@/lib/auth'\nimport { unauthorized } from '@/lib/errors'\n\nexport async function deleteUser(userId: string) {\n  // Always check auth inside the action\n  const session = await verifySession()\n  \n  if (!session) {\n    throw unauthorized('Must be logged in')\n  }\n  \n  // Check authorization too\n  if (session.user.role !== 'admin' && session.user.id !== userId) {\n    throw unauthorized('Cannot delete other users')\n  }\n  \n  await db.user.delete({ where: { id: userId } })\n  return { success: true }\n}\n```\n\n**With input validation:**\n\n```typescript\n'use server'\n\nimport { verifySession } from '@/lib/auth'\nimport { z } from 'zod'\n\nconst updateProfileSchema = z.object({\n  userId: z.string().uuid(),\n  name: z.string().min(1).max(100),\n  email: z.string().email()\n})\n\nexport async function updateProfile(data: unknown) {\n  // Validate input first\n  const validated = updateProfileSchema.parse(data)\n  \n  // Then authenticate\n  const session = await verifySession()\n  if (!session) {\n    throw new Error('Unauthorized')\n  }\n  \n  // Then authorize\n  if (session.user.id !== validated.userId) {\n    throw new Error('Can only update own profile')\n  }\n  \n  // Finally perform the mutation\n  await db.user.update({\n    where: { id: validated.userId },\n    data: {\n      name: validated.name,\n      email: validated.email\n    }\n  })\n  \n  return { success: true }\n}\n```\n\nReference: [https://nextjs.org/docs/app/guides/authentication](https://nextjs.org/docs/app/guides/authentication)",
        "---\ntitle: Cross-Request LRU Caching\nimpact: HIGH\nimpactDescription: caches across requests\ntags: server, cache, lru, cross-request\n---\n\n## Cross-Request LRU Caching\n\n`React.cache()` only works within one request. For data shared across sequential requests (user clicks button A then button B), use an LRU cache.\n\n**Implementation:**\n\n```typescript\nimport { LRUCache } from 'lru-cache'\n\nconst cache = new LRUCache<string, any>({\n  max: 1000,\n  ttl: 5 * 60 * 1000  // 5 minutes\n})\n\nexport async function getUser(id: string) {\n  const cached = cache.get(id)\n  if (cached) return cached\n\n  const user = await db.user.findUnique({ where: { id } })\n  cache.set(id, user)\n  return user\n}\n\n// Request 1: DB query, result cached\n// Request 2: cache hit, no DB query\n```\n\nUse when sequential user actions hit multiple endpoints needing the same data within seconds.\n\n**With Vercel's [Fluid Compute](https://vercel.com/docs/fluid-compute):** LRU caching is especially effective because multiple concurrent requests can share the same function instance and cache. This means the cache persists across requests without needing external storage like Redis.\n\n**In traditional serverless:** Each invocation runs in isolation, so consider Redis for cross-process caching.\n\nReference: [https://github.com/isaacs/node-lru-cache](https://github.com/isaacs/node-lru-cache)",
        "---\ntitle: Per-Request Deduplication with React.cache()\nimpact: MEDIUM\nimpactDescription: deduplicates within request\ntags: server, cache, react-cache, deduplication\n---\n\n## Per-Request Deduplication with React.cache()\n\nUse `React.cache()` for server-side request deduplication. Authentication and database queries benefit most.\n\n**Usage:**\n\n```typescript\nimport { cache } from 'react'\n\nexport const getCurrentUser = cache(async () => {\n  const session = await auth()\n  if (!session?.user?.id) return null\n  return await db.user.findUnique({\n    where: { id: session.user.id }\n  })\n})\n```\n\nWithin a single request, multiple calls to `getCurrentUser()` execute the query only once.\n\n**Avoid inline objects as arguments:**\n\n`React.cache()` uses shallow equality (`Object.is`) to determine cache hits. Inline objects create new references each call, preventing cache hits.\n\n**Incorrect (always cache miss):**\n\n```typescript\nconst getUser = cache(async (params: { uid: number }) => {\n  return await db.user.findUnique({ where: { id: params.uid } })\n})\n\n// Each call creates new object, never hits cache\ngetUser({ uid: 1 })\ngetUser({ uid: 1 })  // Cache miss, runs query again\n```\n\n**Correct (cache hit):**\n\n```typescript\nconst getUser = cache(async (uid: number) => {\n  return await db.user.findUnique({ where: { id: uid } })\n})\n\n// Primitive args use value equality\ngetUser(1)\ngetUser(1)  // Cache hit, returns cached result\n```\n\nIf you must pass objects, pass the same reference:\n\n```typescript\nconst params = { uid: 1 }\ngetUser(params)  // Query runs\ngetUser(params)  // Cache hit (same reference)\n```\n\n**Next.js-Specific Note:**\n\nIn Next.js, the `fetch` API is automatically extended with request memoization. Requests with the same URL and options are automatically deduplicated within a single request, so you don't need `React.cache()` for `fetch` calls. However, `React.cache()` is still essential for other async tasks:\n\n- Database queries (Prisma, Drizzle, etc.)\n- Heavy computations\n- Authentication checks\n- File system operations\n- Any non-fetch async work\n\nUse `React.cache()` to deduplicate these operations across your component tree.\n\nReference: [React.cache documentation](https://react.dev/reference/react/cache)",
        "---\ntitle: Avoid Duplicate Serialization in RSC Props\nimpact: LOW\nimpactDescription: reduces network payload by avoiding duplicate serialization\ntags: server, rsc, serialization, props, client-components\n---\n\n## Avoid Duplicate Serialization in RSC Props\n\n**Impact: LOW (reduces network payload by avoiding duplicate serialization)**\n\nRSC\u2192client serialization deduplicates by object reference, not value. Same reference = serialized once; new reference = serialized again. Do transformations (`.toSorted()`, `.filter()`, `.map()`) in client, not server.\n\n**Incorrect (duplicates array):**\n\n```tsx\n// RSC: sends 6 strings (2 arrays \u00d7 3 items)\n<ClientList usernames={usernames} usernamesOrdered={usernames.toSorted()} />\n```\n\n**Correct (sends 3 strings):**\n\n```tsx\n// RSC: send once\n<ClientList usernames={usernames} />\n\n// Client: transform there\n'use client'\nconst sorted = useMemo(() => [...usernames].sort(), [usernames])\n```\n\n**Nested deduplication behavior:**\n\nDeduplication works recursively. Impact varies by data type:\n\n- `string[]`, `number[]`, `boolean[]`: **HIGH impact** - array + all primitives fully duplicated\n- `object[]`: **LOW impact** - array duplicated, but nested objects deduplicated by reference\n\n```tsx\n// string[] - duplicates everything\nusernames={['a','b']} sorted={usernames.toSorted()} // sends 4 strings\n\n// object[] - duplicates array structure only\nusers={[{id:1},{id:2}]} sorted={users.toSorted()} // sends 2 arrays + 2 unique objects (not 4)\n```\n\n**Operations breaking deduplication (create new references):**\n\n- Arrays: `.toSorted()`, `.filter()`, `.map()`, `.slice()`, `[...arr]`\n- Objects: `{...obj}`, `Object.assign()`, `structuredClone()`, `JSON.parse(JSON.stringify())`\n\n**More examples:**\n\n```tsx\n// \u274c Bad\n<C users={users} active={users.filter(u => u.active)} />\n<C product={product} productName={product.name} />\n\n// \u2705 Good\n<C users={users} />\n<C product={product} />\n// Do filtering/destructuring in client\n```\n\n**Exception:** Pass derived data when transformation is expensive or client doesn't need original.",
        "---\ntitle: Parallel Data Fetching with Component Composition\nimpact: CRITICAL\nimpactDescription: eliminates server-side waterfalls\ntags: server, rsc, parallel-fetching, composition\n---\n\n## Parallel Data Fetching with Component Composition\n\nReact Server Components execute sequentially within a tree. Restructure with composition to parallelize data fetching.\n\n**Incorrect (Sidebar waits for Page's fetch to complete):**\n\n```tsx\nexport default async function Page() {\n  const header = await fetchHeader()\n  return (\n    <div>\n      <div>{header}</div>\n      <Sidebar />\n    </div>\n  )\n}\n\nasync function Sidebar() {\n  const items = await fetchSidebarItems()\n  return <nav>{items.map(renderItem)}</nav>\n}\n```\n\n**Correct (both fetch simultaneously):**\n\n```tsx\nasync function Header() {\n  const data = await fetchHeader()\n  return <div>{data}</div>\n}\n\nasync function Sidebar() {\n  const items = await fetchSidebarItems()\n  return <nav>{items.map(renderItem)}</nav>\n}\n\nexport default function Page() {\n  return (\n    <div>\n      <Header />\n      <Sidebar />\n    </div>\n  )\n}\n```\n\n**Alternative with children prop:**\n\n```tsx\nasync function Header() {\n  const data = await fetchHeader()\n  return <div>{data}</div>\n}\n\nasync function Sidebar() {\n  const items = await fetchSidebarItems()\n  return <nav>{items.map(renderItem)}</nav>\n}\n\nfunction Layout({ children }: { children: ReactNode }) {\n  return (\n    <div>\n      <Header />\n      {children}\n    </div>\n  )\n}\n\nexport default function Page() {\n  return (\n    <Layout>\n      <Sidebar />\n    </Layout>\n  )\n}\n```",
        "---\ntitle: Minimize Serialization at RSC Boundaries\nimpact: HIGH\nimpactDescription: reduces data transfer size\ntags: server, rsc, serialization, props\n---\n\n## Minimize Serialization at RSC Boundaries\n\nThe React Server/Client boundary serializes all object properties into strings and embeds them in the HTML response and subsequent RSC requests. This serialized data directly impacts page weight and load time, so **size matters a lot**. Only pass fields that the client actually uses.\n\n**Incorrect (serializes all 50 fields):**\n\n```tsx\nasync function Page() {\n  const user = await fetchUser()  // 50 fields\n  return <Profile user={user} />\n}\n\n'use client'\nfunction Profile({ user }: { user: User }) {\n  return <div>{user.name}</div>  // uses 1 field\n}\n```\n\n**Correct (serializes only 1 field):**\n\n```tsx\nasync function Page() {\n  const user = await fetchUser()\n  return <Profile name={user.name} />\n}\n\n'use client'\nfunction Profile({ name }: { name: string }) {\n  return <div>{name}</div>\n}\n```",
        "# Typescript Guidelines\n\n- Use explicit types for public APIs and exported functions\n- Avoid `any`; prefer `unknown` with type guards\n- Keep functions small and single-purpose\n- Prefer `const` and readonly data where possible\n- Validate external inputs at the boundary"
      ],
      "rules_dirs": [],
      "rules_files": [],
      "tech": [
        "react",
        "typescript"
      ],
      "branch_strategy": "hybrid",
      "base_branch": "agent/frontend",
      "model": "deepseek-chat",
      "provider": "deepseek",
      "token_budget": null,
      "max_sessions": null,
      "execution_mode": "sdk",
      "task": null,
      "wait_for_pending": false,
      "execution_phase": 1,
      "agent_type": "frontend",
      "workspace_dir": "frontend",
      "repo_url": null
    }
  ],
  "defaults": {
    "branch_strategy": "hybrid",
    "model": "claude-sonnet-4-20250514",
    "provider": "claude",
    "token_budget": 100000,
    "sync_interval": 5,
    "auto_continue_delay": 3.0,
    "execution_mode": "sdk"
  },
  "project_description": "A training application with courses, lessons, progress tracking, quizzes, and user management",
  "project_tech": [
    "typescript",
    "react",
    "nest"
  ],
  "tech_rules": {},
  "conflict_resolution": {}
}